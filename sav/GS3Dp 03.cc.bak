/*
 * GS3D - Fixed32 Optimized Renderer
 *
 * Overview & Algorithm (English):
 * -------------------------------
 * This file implements a compact, high-performance 3D rendering pipeline
 * optimized for fixed-point arithmetic (16.16 format). Key stages:
 *
 * 1) Model input: simplified OBJ files are parsed into vertex arrays and
 *    a packed face-index buffer (memory-efficient layout for limited platforms).
 *
 * 2) Transformation to observer (camera) space: each vertex is rotated
 *    by horizontal (Y-axis) and vertical (X-axis) angles and translated by
 *    the observer distance to produce observer-space coordinates (xo, yo, zo).
 *
 * 3) Perspective projection & 2D rotation: visible vertices (zo > 0) are
 *    projected using (x * scale / zo) and (y * scale / zo) then shifted to
 *    screen center; a final 2D rotation is applied to the result.
 *
 * 4) Raster-ready integer coordinates: projections are computed in fixed-point
 *    and rounded to integer pixel coordinates using an explicit rounding helper
 *    to avoid systematic half-pixel bias that causes visible misalignment.
 *
 * 5) Depth & visibility: per-face z_min / z_max / z_mean are calculated from
 *    transformed vertices to support depth sorting and conservative culling.
 *
 * 6) Painter's algorithm with Newell/Sancha corrections:
 *    - Initial stable sort by face mean depth (z_mean).
 *    - For potentially overlapping pairs (2D bbox overlap + depth overlap),
 *      apply plane-side tests and a small epsilon tolerance to determine
 *      deterministic ordering (avoid flicker due to rounding noise).
 *    - No polygon splitting: instead, order is corrected with pairwise swaps
 *      recorded to prevent oscillations during iterative passes.
 *
 * Implementation notes:
 * - All critical math uses 16.16 fixed-point (Fixed32) with 64-bit intermediates
 *   for multiplication/division to prevent overflow and maintain precision.
 * - Trigonometry uses precomputed integer tables for performance (360 entries).
 * - The code emphasizes deterministic and stable ordering to avoid rendering
 *   artifacts on constrained hardware.
 */

// Header includes and system dependencies

#include <stdio.h>
#include <asm.h>
#include <string.h>
#include <misctool.h>
#include <stdlib.h>
#include <math.h>
#include <quickdraw.h>
#include <event.h>
#include <memory.h>
#include <window.h>
#include <orca.h>

int readVertices_last_count = 0;

static Handle globalPolyHandle = NULL;
static int poly_handle_locked = 0;





typedef long Fixed32;           
typedef long long Fixed64;      

#define FIXED_SHIFT     16
#define FIXED_SCALE     (1L << FIXED_SHIFT)
#define FIXED_MASK      (FIXED_SCALE - 1)
#define FIXED_HALF      (FIXED_SCALE >> 1)


#define FIXED_PI        205887L
#define FIXED_2PI       411775L
#define FIXED_PI_2      102944L
#define FIXED_ONE       FIXED_SCALE
#define FIXED_PI_180    1143LL




static const Fixed32 sin_table[360] = {
    0, 1144, 2287, 3430, 4572, 5712, 6850, 7987, 9121, 10252,
    11380, 12505, 13626, 14742, 15855, 16962, 18064, 19161, 20252, 21336,
    22415, 23486, 24550, 25607, 26656, 27697, 28729, 29753, 30767, 31772,
    32768, 33754, 34729, 35693, 36647, 37590, 38521, 39441, 40348, 41243,
    42126, 42995, 43852, 44695, 45525, 46341, 47143, 47930, 48703, 49461,
    50203, 50931, 51643, 52339, 53020, 53684, 54332, 54963, 55578, 56175,
    56756, 57319, 57865, 58393, 58903, 59396, 59870, 60326, 60764, 61183,
    61584, 61966, 62328, 62672, 62997, 63303, 63589, 63856, 64104, 64332,
    64540, 64729, 64898, 65048, 65177, 65287, 65376, 65446, 65496, 65526,
    65536, 65526, 65496, 65446, 65376, 65287, 65177, 65048, 64898, 64729,
    64540, 64332, 64104, 63856, 63589, 63303, 62997, 62672, 62328, 61966,
    61584, 61183, 60764, 60326, 59870, 59396, 58903, 58393, 57865, 57319,
    56756, 56175, 55578, 54963, 54332, 53684, 53020, 52339, 51643, 50931,
    50203, 49461, 48703, 47930, 47143, 46341, 45525, 44695, 43852, 42995,
    42126, 41243, 40348, 39441, 38521, 37590, 36647, 35693, 34729, 33754,
    32768, 31772, 30767, 29753, 28729, 27697, 26656, 25607, 24550, 23486,
    22415, 21336, 20252, 19161, 18064, 16962, 15855, 14742, 13626, 12505,
    11380, 10252, 9121, 7987, 6850, 5712, 4572, 3430, 2287, 1144,
    0, -1144, -2287, -3430, -4572, -5712, -6850, -7987, -9121, -10252,
    -11380, -12505, -13626, -14742, -15855, -16962, -18064, -19161, -20252, -21336,
    -22415, -23486, -24550, -25607, -26656, -27697, -28729, -29753, -30767, -31772,
    -32768, -33754, -34729, -35693, -36647, -37590, -38521, -39441, -40348, -41243,
    -42126, -42995, -43852, -44695, -45525, -46341, -47143, -47930, -48703, -49461,
    -50203, -50931, -51643, -52339, -53020, -53684, -54332, -54963, -55578, -56175,
    -56756, -57319, -57865, -58393, -58903, -59396, -59870, -60326, -60764, -61183,
    -61584, -61966, -62328, -62672, -62997, -63303, -63589, -63856, -64104, -64332,
    -64540, -64729, -64898, -65048, -65177, -65287, -65376, -65446, -65496, -65526,
    -65536, -65526, -65496, -65446, -65376, -65287, -65177, -65048, -64898, -64729,
    -64540, -64332, -64104, -63856, -63589, -63303, -62997, -62672, -62328, -61966,
    -61584, -61183, -60764, -60326, -59870, -59396, -58903, -58393, -57865, -57319,
    -56756, -56175, -55578, -54963, -54332, -53684, -53020, -52339, -51643, -50931,
    -50203, -49461, -48703, -47930, -47143, -46341, -45525, -44695, -43852, -42995,
    -42126, -41243, -40348, -39441, -38521, -37590, -36647, -35693, -34729, -33754,
    -32768, -31772, -30767, -29753, -28729, -27697, -26656, -25607, -24550, -23486,
    -22415, -21336, -20252, -19161, -18064, -16962, -15855, -14742, -13626, -12505,
    -11380, -10252, -9121, -7987, -6850, -5712, -4572, -3430, -2287, -1144,
};
static const Fixed32 cos_table[360] = {
    65536, 65526, 65496, 65446, 65376, 65287, 65177, 65048, 64898, 64729,
    64540, 64332, 64104, 63856, 63589, 63303, 62997, 62672, 62328, 61966,
    61584, 61183, 60764, 60326, 59870, 59396, 58903, 58393, 57865, 57319,
    56756, 56175, 55578, 54963, 54332, 53684, 53020, 52339, 51643, 50931,
    50203, 49461, 48703, 47930, 47143, 46341, 45525, 44695, 43852, 42995,
    42126, 41243, 40348, 39441, 38521, 37590, 36647, 35693, 34729, 33754,
    32768, 31772, 30767, 29753, 28729, 27697, 26656, 25607, 24550, 23486,
    22415, 21336, 20252, 19161, 18064, 16962, 15855, 14742, 13626, 12505,
    11380, 10252, 9121, 7987, 6850, 5712, 4572, 3430, 2287, 1144,
    0, -1144, -2287, -3430, -4572, -5712, -6850, -7987, -9121, -10252,
    -11380, -12505, -13626, -14742, -15855, -16962, -18064, -19161, -20252, -21336,
    -22415, -23486, -24550, -25607, -26656, -27697, -28729, -29753, -30767, -31772,
    -32768, -33754, -34729, -35693, -36647, -37590, -38521, -39441, -40348, -41243,
    -42126, -42995, -43852, -44695, -45525, -46341, -47143, -47930, -48703, -49461,
    -50203, -50931, -51643, -52339, -53020, -53684, -54332, -54963, -55578, -56175,
    -56756, -57319, -57865, -58393, -58903, -59396, -59870, -60326, -60764, -61183,
    -61584, -61966, -62328, -62672, -62997, -63303, -63589, -63856, -64104, -64332,
    -64540, -64729, -64898, -65048, -65177, -65287, -65376, -65446, -65496, -65526,
    -65536, -65526, -65496, -65446, -65376, -65287, -65177, -65048, -64898, -64729,
    -64540, -64332, -64104, -63856, -63589, -63303, -62997, -62672, -62328, -61966,
    -61584, -61183, -60764, -60326, -59870, -59396, -58903, -58393, -57865, -57319,
    -56756, -56175, -55578, -54963, -54332, -53684, -53020, -52339, -51643, -50931,
    -50203, -49461, -48703, -47930, -47143, -46341, -45525, -44695, -43852, -42995,
    -42126, -41243, -40348, -39441, -38521, -37590, -36647, -35693, -34729, -33754,
    -32768, -31772, -30767, -29753, -28729, -27697, -26656, -25607, -24550, -23486,
    -22415, -21336, -20252, -19161, -18064, -16962, -15855, -14742, -13626, -12505,
    -11380, -10252, -9121, -7987, -6850, -5712, -4572, -3430, -2287, -1144,
    0, 1144, 2287, 3430, 4572, 5712, 6850, 7987, 9121, 10252,
    11380, 12505, 13626, 14742, 15855, 16962, 18064, 19161, 20252, 21336,
    22415, 23486, 24550, 25607, 26656, 27697, 28729, 29753, 30767, 31772,
    32768, 33754, 34729, 35693, 36647, 37590, 38521, 39441, 40348, 41243,
    42126, 42995, 43852, 44695, 45525, 46341, 47143, 47930, 48703, 49461,
    50203, 50931, 51643, 52339, 53020, 53684, 54332, 54963, 55578, 56175,
    56756, 57319, 57865, 58393, 58903, 59396, 59870, 60326, 60764, 61183,
    61584, 61966, 62328, 62672, 62997, 63303, 63589, 63856, 64104, 64332,
    64540, 64729, 64898, 65048, 65177, 65287, 65376, 65446, 65496, 65526,
};


static inline Fixed32 sin_deg(Fixed32 angle) {
    int deg = (int)(angle >> FIXED_SHIFT);
    deg %= 360; if (deg < 0) deg += 360;
    return sin_table[deg];
}
static inline Fixed32 cos_deg(Fixed32 angle) {
    int deg = (int)(angle >> FIXED_SHIFT);
    deg %= 360; if (deg < 0) deg += 360;
    return cos_table[deg];
}


static inline Fixed32 sin_deg_int(int deg) {
    deg %= 360;
    if (deg < 0) deg += 360;
    return sin_table[deg];
}
static inline Fixed32 cos_deg_int(int deg) {
    deg %= 360;
    if (deg < 0) deg += 360;
    return cos_table[deg];
}


#define INT_TO_FIXED(x)     ((Fixed32)(x) << FIXED_SHIFT)
#define FIXED_TO_INT(x)     ((int)((x) >> FIXED_SHIFT))

static inline int FIXED_ROUND_TO_INT(Fixed32 x) {
    if (x >= 0) return (int)(((x) + FIXED_HALF) >> FIXED_SHIFT);
    else return (int)(((x) - FIXED_HALF) >> FIXED_SHIFT);
}
#define FLOAT_TO_FIXED(x)   ((Fixed32)((x) * FIXED_SCALE))
#define FIXED_TO_FLOAT(x)   ((float)(x) / (float)FIXED_SCALE)


#define FIXED_ADD(a, b)     ((a) + (b))
#define FIXED_SUB(a, b)     ((a) - (b))
#define FIXED_NEG(x)        (-(x))
#define FIXED_ABS(x)        ((x) >= 0 ? (x) : -(x))
#define FIXED_FRAC(x)       ((x) & FIXED_MASK)


#define FIXED_MUL(a, b)     (((long)(a) * (long)(b)) >> FIXED_SHIFT)
#define FIXED_DIV(a, b)     (((long)(a) << FIXED_SHIFT) / (long)(b))


#define FIXED_MUL_64(a, b)  ((Fixed32)(((Fixed64)(a) * (Fixed64)(b)) >> FIXED_SHIFT))
#define FIXED_DIV_64(a, b)  ((Fixed32)(((Fixed64)(a) << FIXED_SHIFT) / (Fixed64)(b)))
#define FIXED64_TO_32(x)    ((Fixed32)(x))




static inline int normalize_deg(int deg) {
    deg %= 360;
    if (deg < 0) deg += 360;
    return deg;
}




#define ENABLE_DEBUG_SAVE 0
//#define PERFORMANCE_MODE 0

#define PERFORMANCE_MODE 0

#define MAX_LINE_LENGTH 256
#define MAX_VERTICES 6000
#define MAX_FACES 6000
#define MAX_FACE_VERTICES 6
#define PI 3.14159265359
#define CENTRE_X 160
#define CENTRE_Y 100
//#define mode 640               // Graphics mode 640x200 pixels
#define mode 320



/**
 * Structure Vertex3D
 * 
 * DESCRIPTION:
 *   Represents a point in 3D space with its different representations
 *   throughout the 3D rendering pipeline.
 * 
 * FIELDS:
 *   x, y, z    : Original coordinates read from OBJ file
 *   xo, yo, zo : Transformed coordinates in the observer system
 *                (after applying rotations and translation)
 *   x2d, y2d   : Final projected coordinates on 2D screen
 * 
 * USAGE:
 *   This structure preserves all transformation steps to
 *   allow debugging and recalculations without rereading the file.
 */



typedef struct {
    Handle xHandle, yHandle, zHandle;
    Handle xoHandle, yoHandle, zoHandle;
    Handle x2dHandle, y2dHandle;
    Fixed32 *x, *y, *z;
    Fixed32 *xo, *yo, *zo;
    int *x2d, *y2d;
    int vertex_count;
} VertexArrays3D;

/**
 * Structure FaceArrays3D - Compact dynamic face storage with depth-sorted rendering
 * Each face stores ONLY the vertices it needs:
 * - vertex_count: How many vertices this face has (3 for tri, 4 for quad, etc.)
 * - vertex_indices_buffer: ONE packed buffer with all indices (NO WASTED SLOTS!)
 * - vertex_indices_ptr: Offset array pointing to each face's slice in the buffer
 * - sorted_face_indices: Array of face indices SORTED by depth (for painter's algorithm)
 * - z_max: Depth for sorting
 * - display_flag: Culling flag
 * 
 * MEMORY LAYOUT:
 * Instead of 4 arrays of 6000 elements each, we use ONE packed buffer.
 * Triangles (1538 faces × 3 indices) + Quads (2504 faces × 4 indices) = packed linearly
 * Saves ~40-60% memory vs fixed 4 vertices/face
 * 
 * DEPTH SORTING STRATEGY:
 * Instead of moving data around (complex with variable-length indices), we maintain
 * sorted_face_indices[] which contains face numbers in depth order (farthest first).
 * Drawing loop: for(i=0; i<face_count; i++) { int face_id = sorted_face_indices[i]; ... }
 * This keeps the buffer untouched while providing correct rendering order.
 */
typedef struct {
    Handle vertex_countHandle;
    Handle vertex_indicesBufferHandle;
    Handle vertex_indicesPtrHandle;
    Handle z_maxHandle;
    Handle display_flagHandle;
    Handle sorted_face_indicesHandle;
    
    int *vertex_count;
    int *vertex_indices_buffer;
    int *vertex_indices_ptr;
    Fixed32 *z_min;
    Fixed32 *z_max;
    Fixed32 *z_mean;
    Fixed32 *plane_a;
    Fixed32 *plane_b;
    Fixed32 *plane_c;
    Fixed32 *plane_d;
    int *minx;
    int *maxx;
    int *miny;
    int *maxy;
    int *display_flag;
    int *sorted_face_indices;
    int face_count;
    int total_indices;
} FaceArrays3D;


typedef struct {
    int vertex_count;
    int vertex_indices[MAX_FACE_VERTICES];
    Fixed32 z_max;
    int display_flag;
} Face3D;


typedef struct {
    int polySize;
    Rect polyBBox;
    Point polyPoints[MAX_FACE_VERTICES];
} DynamicPolygon;


 *   - Angles are in degrees (converted to radians for calculations)
 *   - Distance affects perspective and apparent size
 *   - angle_w allows final rotation to adjust orientation
 */
typedef struct {
    int angle_h;
    int angle_v;
    int angle_w;
    Fixed32 distance;
} ObserverParams;

/**
 * Structure Model3D
 * 
 * DESCRIPTION:
 *   Main structure containing all data of a 3D model.
 *   It groups vertices, faces, and associated counters.
 * 
 * FIELDS:
 *   vertices      : Pointer to dynamic vertex array
 *   faces         : Pointer to dynamic face array
 *   vertex_count  : Actual number of loaded vertices
 *   face_count    : Actual number of loaded faces
 * 
 * MEMORY MANAGEMENT:
 *   - Arrays are dynamically allocated (malloc)
 *   - Allows exceeding Apple IIGS stack limits
 *   - Mandatory cleanup with destroyModel3D()
 * 
 * USAGE:
 *   Model3D* model = createModel3D();
 *   loadModel3D(model, "file.obj");
 *   // ... usage ...
 *   destroyModel3D(model);
 */
typedef struct {
    VertexArrays3D vertices;          // Parallel arrays for all vertex data
    FaceArrays3D faces;               // Parallel arrays for all face data
} Model3D;




Fixed32 sin_fixed(Fixed32 angle);
Fixed32 cos_fixed(Fixed32 angle);




/**
 * 3D GEOMETRIC TRANSFORMATION FUNCTIONS
 * =====================================
 */

/**
 * transformToObserver
 * 
 * DESCRIPTION:
 *   Applies 3D geometric transformations to go from the model's
 *   coordinate system to the observer's coordinate system.
 *   
 *   APPLIED TRANSFORMATIONS:
 *   1. Horizontal rotation (angle_h) around Y-axis
 *   2. Vertical rotation (angle_v) around X-axis
 *   3. Translation by observation distance
 * 
 * PARAMETERS:
 *   vertices     : Array of vertices to transform
 *   vertex_count : Number of vertices in the array
 *   angle_h      : Horizontal rotation angle (degrees)
 *   angle_v      : Vertical rotation angle (degrees)
 *   distance     : Observation distance (Z translation)
 * 
 * MATHEMATICAL FORMULAS:
 *   zo = -x*(cos_h*cos_v) - y*(sin_h*cos_v) - z*sin_v + distance
 *   xo = -x*sin_h + y*cos_h
 *   yo = -x*(cos_h*sin_v) - y*(sin_h*sin_v) + z*cos_v
 * 
 * RESULTING COORDINATES:
 *   The xo, yo, zo fields of the vertices are updated.
 */
void transformToObserver(VertexArrays3D* vtx, int angle_h_deg, int angle_v_deg, Fixed32 distance);

/**
 * projectTo2D
 * 
 * DESCRIPTION:
 *   Projects the transformed 3D coordinates onto a 2D screen using
 *   perspective projection. Also applies a final rotation
 *   in the 2D plane.
 * 
 * PARAMETERS:
 *   vertices     : Array of vertices to project
 *   vertex_count : Number of vertices in the array
 *   angle_w      : Rotation angle in the 2D plane (degrees)
 * 
 * ALGORITHM:
 *   1. Perspective projection: x2d = (xo * scale) / zo + center_x
 *   2. Same for y2d with Y-axis inversion
 *   3. Final rotation in the 2D plane according to angle_w
 *   4. Points behind observer (zo <= 0) marked invisible
 * 
 * RESULTING COORDINATES:
 *   The x2d, y2d fields of the vertices contain the final screen coordinates.
 */
/*
 * projectTo2D
 * -----------
 * Project observer-space vertices onto 2D screen coordinates and apply
 * a final 2D rotation (angle_w).
 *
 * Algorithm:
 *  - For each vertex with zo > 0 (in front of the camera):
 *      inv_zo = scale / zo
 *      x_proj = centre_x + xo * inv_zo
 *      y_proj = centre_y - yo * inv_zo    (Y inverted to match screen coords)
 *  - Apply a rotation in the 2D plane around the screen center:
 *      x2 = cos_w*(x_proj - cx) - sin_w*(cy - y_proj) + cx
 *      y2 = cy - ( sin_w*(x_proj - cx) + cos_w*(cy - y_proj) )
 *  - Round the final fixed-point coordinates to integer pixels using an
 *    explicit nearest-round helper to avoid half-pixel bias.
 *  - Mark vertices with zo <= 0 as invisible (-1).
 */
void projectTo2D(VertexArrays3D* vtx, int angle_w_deg);

/**
 * GRAPHIC RENDERING FUNCTIONS
 * ===========================
 */

/**
 * drawPolygons
 * 
 * DESCRIPTION:
 *   Draws all polygons (faces) of the 3D model on screen using
 *   Apple IIGS QuickDraw API. Each face is rendered with a different
 *   color for visualization.
 * 
 * PARAMETERS:
 *   vertices   : Array of vertices with calculated 2D coordinates
 *   faces      : Array of faces to draw
 *   face_count : Number of faces in the array
 * 
 * ALGORITHM:
 *   1. QuickDraw graphics mode initialization
 *   2. For each face:
 *      - Check vertex visibility
 *      - Create QuickDraw polygon structure
 *      - Calculate bounding box
 *      - Dynamic memory allocation
 *      - Drawing with PaintPoly()
 *      - Memory cleanup
 * 
 * COLOR MANAGEMENT:
 *   Cyclic colors based on face index (i % 15 + 1)
 * 
 * OPTIMIZATIONS:
 *   - Faces with less than 3 visible vertices ignored
 *   - Off-screen vertices handled correctly
 */
void drawPolygons(Model3D* model, int* vertex_count, int face_count, int vertex_count_total);
/*
 * calculateFaceDepths
 * -------------------
 * Compute per-face depth statistics and visibility flags used by the
 * painter's algorithm and culling steps.
 *
 * For each face:
 *  - z_min: minimum zo among vertices (closest point)
 *  - z_max: maximum zo among vertices (farthest point)
 *  - z_mean: mean zo used for a stable initial sort
 *  - display_flag: set to 0 if any vertex is behind camera (zo <= 0)
 *  - cached 2D bounding box (minx,maxx,miny,maxy) in integer pixel space
 *
 * The conservative rule (cull when any vertex is behind camera) prevents
 * partial/wrapping polygons from being projected incorrectly.
 */
void calculateFaceDepths(Model3D* model, Face3D* faces, int face_count);


/**
 * PAINTER'S ALGORITHM - NEWELL/SANCHA
 * ===================================
 * Tri Z décroissant, puis test de recouvrement 2D (bounding box)
 * Corrige l'ordre si recouvrement ambigu (sans split)
 *
 * Appel : painter_newell_sancha(model, face_count);
 */


static FaceArrays3D* qsort_faces_ptr_for_cmp = NULL;
static int cmp_faces_by_zmean(const void* pa, const void* pb) {
    int a = *(const int*)pa;
    int b = *(const int*)pb;
    Fixed32 za = qsort_faces_ptr_for_cmp->z_mean[a];
    Fixed32 zb = qsort_faces_ptr_for_cmp->z_mean[b];
    if (za > zb) return -1;   // larger z_mean first (descending)
    if (za < zb) return 1;
    if (a < b) return -1;     // tie-breaker: smaller index first
    if (a > b) return 1;
    return 0;
}

/*
 * painter_newell_sancha
 * ---------------------
 * Stable painter's algorithm enhanced with Newell/Sancha overlap tests.
 * Implementation steps:
 * 1) Initialize sorted_face_indices to [0..face_count-1]
 * 2) Stable sort by z_mean (descending) to create an initial back-to-front order
 * 3) Iteratively scan adjacent pairs; when 2D bounding boxes overlap and
 *    depth quick-tests indicate potential conflict, apply plane-side tests:
 *    - Use plane normals and D terms (precomputed per-face) to determine
 *      whether one face lies consistently in front of the other with a
 *      small epsilon tolerance to avoid flip-flopping due to rounding.
 * 4) For ambiguous cases the algorithm records ordered pairs and performs
 *    pairwise swaps until convergence (no swaps). This avoids polygon splitting
 *    while producing a deterministic ordering for rendering.
 */
void painter_newell_sancha(Model3D* model, int face_count) {
    // ...existing code...
    FaceArrays3D* faces = &model->faces;
    VertexArrays3D* vtx = &model->vertices;
    int i, j;
    Fixed32* face_zmean = faces->z_mean;
    if (!face_zmean) return;


    long t_start = GetTick();
    for (i = 0; i < face_count; i++) faces->sorted_face_indices[i] = i;
    qsort_faces_ptr_for_cmp = faces;
    qsort(faces->sorted_face_indices, face_count, sizeof(int), cmp_faces_by_zmean);
    qsort_faces_ptr_for_cmp = NULL;
    long t_end = GetTick();
    if (!PERFORMANCE_MODE)
    {
        long elapsed = t_end - t_start;
            double ms = ((double)elapsed * 1000.0) / 60.0;
    // Utilise une tolérance epsilon pour éviter les oscillations dues aux erreurs d'arrondi
    // Liste des couples de faces ordonnées par les tests de plan pour éviter les oscillations
    int swapped;
    int swap_count = 0;


    // Structure pour stocker les paires de faces ordonnées
    typedef struct {
        int face1;  // Face qui doit être avant
        int face2;  // Face qui doit être après
    } OrderedPair;
    
    // Préallocation unique : meilleure performance en évitant realloc fréquents.
    // On préalloue une capacité basée sur face_count * 4 (choix empirique).
    int ordered_pairs_capacity = face_count * 4;
    OrderedPair* ordered_pairs = NULL;
    if (ordered_pairs_capacity > 0) {
        ordered_pairs = (OrderedPair*)malloc(ordered_pairs_capacity * sizeof(OrderedPair));
        if (!ordered_pairs) {
            // Si l'allocation échoue, revenir au mode dynamique par réallocation (capacity = 0)
            ordered_pairs_capacity = 0;
        }
    }
    int ordered_pairs_count = 0;
    
    do {
        swapped = 0;

        for (i = 0; i < face_count-1; i++) {
            int f1 = faces->sorted_face_indices[i];
            int f2 = faces->sorted_face_indices[i+1];
            
            
            // Vérifier si cette paire a déjà été ordonnée définitivement
            int already_ordered = 0;
            int p;
            for (p = 0; p < ordered_pairs_count; p++) {
                if (ordered_pairs[p].face1 == f1 && ordered_pairs[p].face2 == f2) {
                    already_ordered = 1;
                    break;
                }
            }
            if (already_ordered) {
                continue;
            }

            // Test 1 : Depth overlap

            // Depth quick test: if farthest point of P2 is in front of nearest point of P1, order is respected
            if (faces->z_max[f2] >= faces->z_min[f1]) continue;
            
            // Bounding Box 2D overlap (split into X and Y parts)
            // Use cached bounding boxes (computed in calculateFaceDepths)
            int minx1 = faces->minx[f1], maxx1 = faces->maxx[f1], miny1 = faces->miny[f1], maxy1 = faces->maxy[f1];
            int minx2 = faces->minx[f2], maxx2 = faces->maxx[f2], miny2 = faces->miny[f2], maxy2 = faces->maxy[f2];
        
            // Test 2 : X overlap only

            if (maxx1 < minx2 || maxx2 < minx1) continue;
            
            // Test 3 : Y overlap only

            if (maxy1 < miny2 || maxy2 < miny1) continue;

            // Use cached plane normals and d terms computed in calculateFaceDepths
            int n1 = faces->vertex_count[f1];
            int n2 = faces->vertex_count[f2];
            int offset1 = faces->vertex_indices_ptr[f1];
            int offset2 = faces->vertex_indices_ptr[f2];
            int k;
            Fixed32 a1 = faces->plane_a[f1];
            Fixed32 b1 = faces->plane_b[f1];
            Fixed32 c1 = faces->plane_c[f1];
            Fixed32 d1 = faces->plane_d[f1];
            Fixed32 a2 = faces->plane_a[f2];
            Fixed32 b2 = faces->plane_b[f2];
            Fixed32 c2 = faces->plane_c[f2];
            Fixed32 d2 = faces->plane_d[f2];
            Fixed32 epsilon = FLOAT_TO_FIXED(0.01);

            int obs_side1 = 0; // côté de l'observateur par rapport au plan de f1 : +1, -1 ou 0 (inconclusive)
            int obs_side2 = 0; // côté de l'observateur par rapport au plan de f2 : +1, -1 ou 0 (inconclusive)
            int side;           // coté du vertex.
            int all_same_side; // flag pour indiquer si tous les vertex sont du même coté
            int all_opposite_side; // flag pour indiquer si tous les vertex sont du coté opposé
            Fixed32 test_value;


            // Newell/Sancha plane tests

            // Test 4 : Test si f2 est du même côté que l'observatur par rapport au plan de f1. 

            // Si oui, f2 est bien devant f1, pas d'échange.
            obs_side1 = 0; // sign of d1: +1, -1 or 0 (inconclusive)
            if (d1 > epsilon) obs_side1 = 1; 
            else if (d1 < -epsilon) obs_side1 = -1;
            else goto skipT4; // si l'observateur est sur le plan, on ne peut rien conclure, il faut faire d'autres tests
            all_same_side = 1;
            for (k=0; k<n2; k++) {
                    int v = faces->vertex_indices_buffer[offset2+k]-1;
                    test_value = a1*vtx->xo[v] + b1*vtx->yo[v] + c1*vtx->zo[v] + d1;
                    if  (test_value > epsilon) side = 1;
                    else if (test_value < -epsilon) side = -1;
                    if (obs_side1 != side) { 
                        // si un vertex est de l'autre coté, on sort de la boucle
                        // et on met le flag à 0 pour indiquer que le test a échoué (et passer au test suivant)
                        all_same_side = 0;   
                        break; 
                    }
            }
            if (all_same_side) continue; // faces are ordered correctly, move to next pair

            skipT4:

            // Test 5 : Test si f1 est du coté opposé de l'observateur par rapport au plan de f2. 

            // Si oui, f1 est devant f2, pas d'échange
            obs_side2 = 0; // sign of d1: +1, -1 or 0 (inconclusive)
            if (d2 > epsilon) obs_side2 = 1; 
            else if (d2 < -epsilon) obs_side2 = -1;
            else goto skipT5; // si l'observateur est sur le plan, on ne peut rien conclure, il faut faire d'autres tests
            all_opposite_side = 1;
            for (k=0; k<n1; k++) {
                int v = faces->vertex_indices_buffer[offset1+k]-1;
                test_value = a2*vtx->xo[v] + b2*vtx->yo[v] + c2*vtx->zo[v] + d2;
                if  (test_value > epsilon) side = 1;
                else if (test_value < -epsilon) side = -1;
                if (obs_side2 == side) {
                    // si un vertex est du même coté, on sort de la boucle
                    // et on met le flag à 0 pour indiquer que le test a échoué (et passer au test suivant)
                    all_opposite_side = 0; 
                    break; }
                }
                if (all_opposite_side) continue; // faces are ordered correctly, move to next pair
            
            skipT5:

            // Test 6 : Test si f2 est du  côté opposé de l'observateur par rapport au plan de f1. 

            // Si oui, f2 est derrière f1, on doit échanger l'ordre
            obs_side1 = 0; // sign of d1: +1, -1 or 0 (inconclusive)
            if (d1 > epsilon) obs_side1 = 1; 
            else if (d1 < -epsilon) obs_side1 = -1;
            else goto skipT6; // si l'observateur est sur le plan, on ne peut rien conclure, il faut faire d'autres tests

                all_opposite_side = 1;
                for (k=0; k<n2; k++) {
                    int v = faces->vertex_indices_buffer[offset2+k]-1;
                    int side;
                    if  ((a1*vtx->xo[v] + b1*vtx->yo[v] + c1*vtx->zo[v] + d1) > epsilon) side = 1;
                    else side = -1;
                    if (obs_side1 == side) { 
                        all_opposite_side = 0; 
                        break; 
                        }
                }
                if (all_opposite_side == 0) continue;
                // f2 n'est pas du coté opposé de l'observateur, donc f2 n'est pas derrière f1

                // Si on arrive ici, f2 est du même côté que l'observateur, donc f2 est devant f1
                // on peut donc inverser l'ordre des faces
                else {
                    goto do_swap;
                }

            skipT6: ;

            // Test 7 : Test si f1 est du même côté de l'observateur par rapport au plan de f2. 

            // Si oui, f1 est devant f2, on doit échanger l'ordre
            obs_side2 = 0; // sign of d1: +1, -1 or 0 (inconclusive)
            if (d2 > epsilon) obs_side2 = 1; 
            else if (d2 < -epsilon) obs_side2 = -1;
            else goto skipT7; // si l'observateur est sur le plan, on ne peut rien conclure, il faut faire d'autres tests
            all_same_side = 1;
            for (k=0; k<n1; k++) {
                int v = faces->vertex_indices_buffer[offset1+k]-1;
                int side;
                if  ((a2*vtx->xo[v] + b2*vtx->yo[v] + c2*vtx->zo[v] + d2) > epsilon) side = 1;
                else side = -1;
                if (obs_side2 != side) { 
                    all_same_side = 0; 
                    break; 
                    }
            }
                if (all_same_side == 0) continue;
                // f1 n'est pas du même côté de l'observateur, donc f1 n'est pas devant f2
                // on ne doit pas échanger l'ordre des faces
                else {
                    goto do_swap;
                }

            do_swap: {

                int tmp = faces->sorted_face_indices[i];
                faces->sorted_face_indices[i] = faces->sorted_face_indices[i+1];
                faces->sorted_face_indices[i+1] = tmp;
                swapped = 1;
                swap_count++;
                
                // Ajouter cette paire à la liste des paires ordonnées
                // Après l'échange, f2 est maintenant avant f1 dans le tableau
                // Utiliser uniquement le buffer préalloué (pas de realloc) : si on dépasse la capacité, on ignore la paire
                if (ordered_pairs != NULL && ordered_pairs_count < ordered_pairs_capacity) {
                    ordered_pairs[ordered_pairs_count].face1 = f2;
                    ordered_pairs[ordered_pairs_count].face2 = f1;
                    ordered_pairs_count++;
                }
            }

        skipT7: ;
        // Ici, on devrait découper f1 par f2 (ou inversement), mais on ne le fait pas pour l'instant
        }
            } while (swapped);
    


    // Libérer la mémoire de la liste des paires ordonnées
    if (ordered_pairs) {
        free(ordered_pairs);
    }    
}

/**
 * UTILITY FUNCTIONS
 * ==================
 */


// ============================================================================
//                    FIXED POINT MATHEMATICAL FUNCTIONS
// ============================================================================

/**
 * SINE FUNCTION - Fixed Point Implementation
 * =========================================== 
 * 
 * Calculates sin(x) using Taylor series approximation.
 * Input: angle in radians (fixed point 16.16)
 * Output: sin(angle) in fixed point 16.16
 * 
 * Taylor series: sin(x) = x - x³/3! + x⁵/5! - x⁷/7! + ...
 * Optimized for range [-2π, 2π] with angle normalization.
 */
Fixed32 sin_fixed(Fixed32 angle) {
    while (angle > FIXED_PI) angle = FIXED_SUB(angle, FIXED_2PI);
    while (angle < -FIXED_PI) angle = FIXED_ADD(angle, FIXED_2PI);
    
    Fixed32 x = angle;
    Fixed32 x2 = FIXED_MUL_64(x, x);       // x²
    Fixed32 x3 = FIXED_MUL_64(x2, x);      // x³
    Fixed32 x5 = FIXED_MUL_64(x3, x2);     // x⁵
    Fixed32 x7 = FIXED_MUL_64(x5, x2);     // x⁷
    
    Fixed32 result = x;
    result = FIXED_SUB(result, FIXED_DIV_64(x3, INT_TO_FIXED(6))); 
    result = FIXED_ADD(result, FIXED_DIV_64(x5, INT_TO_FIXED(120))); 
    result = FIXED_SUB(result, FIXED_DIV_64(x7, INT_TO_FIXED(5040))); 
    
    return result;
}

/**
 * COSINE FUNCTION - Fixed Point Implementation
 * ============================================
 * 
 * Calculates cos(x) using the identity: cos(x) = sin(x + π/2)
 * More efficient than separate Taylor series.
 */
Fixed32 cos_fixed(Fixed32 angle) {
    return sin_fixed(FIXED_ADD(angle, FIXED_PI_2));
}

// ============================================================================
//                    3D MODEL MANAGEMENT FUNCTIONS
// ============================================================================

/**
 * CREATING A NEW 3D MODEL
 * ========================
 * 
 * This function dynamically allocates all structures necessary
 * for a 3D model. Dynamic allocation is crucial on Apple IIGS
 * because the stack is limited and cannot contain large arrays.
 * 
 * ALLOCATION STRATEGY:
 * 1. Main Model3D structure allocation
 * 2. Vertex array allocation (MAX_VERTICES elements)
 * 3. Face array allocation (MAX_FACES elements)
 * 4. On failure: cleanup of previous allocations
 * 
 * ERROR HANDLING:
 * - Check each allocation
 * - Automatic cascade cleanup on partial failure
 * - Return NULL if unable to allocate
 */
Model3D* createModel3D(void) {
    // Step 1: Main structure allocation
    Model3D* model = (Model3D*)malloc(sizeof(Model3D));
    if (model == NULL) {
        return NULL;
    }
    int n = MAX_VERTICES;
    model->vertices.vertex_count = n;
    
    // Step 2: Allocate vertex arrays using malloc (handles bank crossing better)
    // Note: malloc() should handle bank boundaries better than NewHandle()
    model->vertices.x = (Fixed32*)malloc(n * sizeof(Fixed32));
    model->vertices.y = (Fixed32*)malloc(n * sizeof(Fixed32));
    model->vertices.z = (Fixed32*)malloc(n * sizeof(Fixed32));
    model->vertices.xo = (Fixed32*)malloc(n * sizeof(Fixed32));
    model->vertices.yo = (Fixed32*)malloc(n * sizeof(Fixed32));
    model->vertices.zo = (Fixed32*)malloc(n * sizeof(Fixed32));
    model->vertices.x2d = (int*)malloc(n * sizeof(int));
    model->vertices.y2d = (int*)malloc(n * sizeof(int));
    
    if (!model->vertices.x || !model->vertices.y || !model->vertices.z ||
        !model->vertices.xo || !model->vertices.yo || !model->vertices.zo ||
        !model->vertices.x2d || !model->vertices.y2d) {
        printf("Error: Unable to allocate memory for vertex arrays\n");
        keypress();
        // Allocation failed, cleanup
        if (model->vertices.x) free(model->vertices.x);
        if (model->vertices.y) free(model->vertices.y);
        if (model->vertices.z) free(model->vertices.z);
        if (model->vertices.xo) free(model->vertices.xo);
        if (model->vertices.yo) free(model->vertices.yo);
        if (model->vertices.zo) free(model->vertices.zo);
        if (model->vertices.x2d) free(model->vertices.x2d);
        if (model->vertices.y2d) free(model->vertices.y2d);
        free(model);
        return NULL;
    }
    
    // Set dummy handles to NULL (not used with malloc)
    model->vertices.xHandle = NULL;
    model->vertices.yHandle = NULL;
    model->vertices.zHandle = NULL;
    model->vertices.xoHandle = NULL;
    model->vertices.yoHandle = NULL;
    model->vertices.zoHandle = NULL;
    model->vertices.x2dHandle = NULL;
    model->vertices.y2dHandle = NULL;
    
    // Step 3: Face array allocation using parallel arrays (like vertices)
    // Each element stored separately to fit 32KB limit per allocation
    int nf = MAX_FACES;
    
    // Allocate vertex count array: nf * 4 bytes = 24KB
    model->faces.vertex_count = (int*)malloc(nf * sizeof(int));
    if (!model->faces.vertex_count) {
        printf("Error: Unable to allocate memory for face vertex_count array\n");
        keypress();
        free(model->vertices.x);
        free(model->vertices.y);
        free(model->vertices.z);
        free(model->vertices.xo);
        free(model->vertices.yo);
        free(model->vertices.zo);
        free(model->vertices.x2d);
        free(model->vertices.y2d);
        free(model);
        return NULL;
    }
    
    // Allocate SINGLE packed buffer for all vertex indices
    // Estimate: average 3.5 indices per face (mix of triangles and quads)
    // For 6000 faces: ~21KB. We allocate conservatively at 5 per face = 120KB max
    int estimated_total_indices = nf * 5;
    model->faces.vertex_indices_buffer = (int*)malloc(estimated_total_indices * sizeof(int));
    if (!model->faces.vertex_indices_buffer) {
        printf("Error: Unable to allocate memory for vertex_indices_buffer\n");
        keypress();
        free(model->vertices.x);
        free(model->vertices.y);
        free(model->vertices.z);
        free(model->vertices.xo);
        free(model->vertices.yo);
        free(model->vertices.zo);
        free(model->vertices.x2d);
        free(model->vertices.y2d);
        free(model->faces.vertex_count);
        free(model);
        return NULL;
    }
    
    // Allocate offset array: one offset per face into the packed buffer
    model->faces.vertex_indices_ptr = (int*)malloc(nf * sizeof(int));
    if (!model->faces.vertex_indices_ptr) {
        printf("Error: Unable to allocate memory for vertex_indices_ptr array\n");
        keypress();
        free(model->vertices.x);
        free(model->vertices.y);
        free(model->vertices.z);
        free(model->vertices.xo);
        free(model->vertices.yo);
        free(model->vertices.zo);
        free(model->vertices.x2d);
        free(model->vertices.y2d);
        free(model->faces.vertex_count);
        free(model->faces.vertex_indices_buffer);
        free(model);
        return NULL;
    }
    
    // Allocate z_min and z_max arrays (min and max depth per face)
    model->faces.z_min = (Fixed32*)malloc(nf * sizeof(Fixed32));
    model->faces.z_max = (Fixed32*)malloc(nf * sizeof(Fixed32));
    if (!model->faces.z_min || !model->faces.z_max) {
        printf("Error: Unable to allocate memory for face depth arrays\n");
        keypress();
        if (model->faces.z_min) free(model->faces.z_min);
        if (model->faces.z_max) free(model->faces.z_max);
        free(model->vertices.x);
        free(model->vertices.y);
        free(model->vertices.z);
        free(model->vertices.xo);
        free(model->vertices.yo);
        free(model->vertices.zo);
        free(model->vertices.x2d);
        free(model->vertices.y2d);
        free(model->faces.vertex_count);
        free(model->faces.vertex_indices_buffer);
        free(model->faces.vertex_indices_ptr);
        free(model);
        return NULL;
    }
    // Allocate z_mean array (mean depth per face) - used by painter_newell_sancha
    model->faces.z_mean = (Fixed32*)malloc(nf * sizeof(Fixed32));
    if (!model->faces.z_mean) {
        printf("Error: Unable to allocate memory for face z_mean array\n");
        keypress();
        if (model->faces.z_mean) free(model->faces.z_mean);
        free(model->vertices.x);
        free(model->vertices.y);
        free(model->vertices.z);
        free(model->vertices.xo);
        free(model->vertices.yo);
        free(model->vertices.zo);
        free(model->vertices.x2d);
        free(model->vertices.y2d);
        free(model->faces.vertex_count);
        free(model->faces.vertex_indices_buffer);
        free(model->faces.vertex_indices_ptr);
        if (model->faces.z_min) free(model->faces.z_min);
        if (model->faces.z_max) free(model->faces.z_max);
        free(model);
        return NULL;
    }

    // Allocate plane coefficient arrays (normalized normals + d term)
    model->faces.plane_a = (Fixed32*)malloc(nf * sizeof(Fixed32));
    model->faces.plane_b = (Fixed32*)malloc(nf * sizeof(Fixed32));
    model->faces.plane_c = (Fixed32*)malloc(nf * sizeof(Fixed32));
    model->faces.plane_d = (Fixed32*)malloc(nf * sizeof(Fixed32));
    if (!model->faces.plane_a || !model->faces.plane_b || !model->faces.plane_c || !model->faces.plane_d) {
        printf("Error: Unable to allocate memory for face plane arrays\n");
        keypress();
        if (model->faces.plane_a) free(model->faces.plane_a);
        if (model->faces.plane_b) free(model->faces.plane_b);
        if (model->faces.plane_c) free(model->faces.plane_c);
        if (model->faces.plane_d) free(model->faces.plane_d);
        if (model->faces.z_mean) free(model->faces.z_mean);
        if (model->faces.z_min) free(model->faces.z_min);
        if (model->faces.z_max) free(model->faces.z_max);
        free(model->vertices.x);
        free(model->vertices.y);
        free(model->vertices.z);
        free(model->vertices.xo);
        free(model->vertices.yo);
        free(model->vertices.zo);
        free(model->vertices.x2d);
        free(model->vertices.y2d);
        free(model->faces.vertex_count);
        free(model->faces.vertex_indices_buffer);
        free(model->faces.vertex_indices_ptr);
        free(model->faces.z_max);
        free(model);
        return NULL;
    }

    // Allocate cached 2D bounding boxes arrays
    model->faces.minx = (int*)malloc(nf * sizeof(int));
    model->faces.maxx = (int*)malloc(nf * sizeof(int));
    model->faces.miny = (int*)malloc(nf * sizeof(int));
    model->faces.maxy = (int*)malloc(nf * sizeof(int));
    if (!model->faces.minx || !model->faces.maxx || !model->faces.miny || !model->faces.maxy) {
        printf("Error: Unable to allocate memory for face bounding box arrays\n");
        keypress();
        if (model->faces.minx) free(model->faces.minx);
        if (model->faces.maxx) free(model->faces.maxx);
        if (model->faces.miny) free(model->faces.miny);
        if (model->faces.maxy) free(model->faces.maxy);
        if (model->faces.plane_a) free(model->faces.plane_a);
        if (model->faces.plane_b) free(model->faces.plane_b);
        if (model->faces.plane_c) free(model->faces.plane_c);
        if (model->faces.plane_d) free(model->faces.plane_d);
        if (model->faces.z_mean) free(model->faces.z_mean);
        if (model->faces.z_min) free(model->faces.z_min);
        if (model->faces.z_max) free(model->faces.z_max);
        free(model->vertices.x);
        free(model->vertices.y);
        free(model->vertices.z);
        free(model->vertices.xo);
        free(model->vertices.yo);
        free(model->vertices.zo);
        free(model->vertices.x2d);
        free(model->vertices.y2d);
        free(model->faces.vertex_count);
        free(model->faces.vertex_indices_buffer);
        free(model->faces.vertex_indices_ptr);
        free(model->faces.z_max);
        free(model);
        return NULL;
    }
    
    // Allocate display_flag array: nf * 4 bytes = 24KB
    model->faces.display_flag = (int*)malloc(nf * sizeof(int));
    if (!model->faces.display_flag) {
        printf("Error: Unable to allocate memory for face display_flag array\n");
        keypress();
        free(model->vertices.x);
        free(model->vertices.y);
        free(model->vertices.z);
        free(model->vertices.xo);
        free(model->vertices.yo);
        free(model->vertices.zo);
        free(model->vertices.x2d);
        free(model->vertices.y2d);
        free(model->faces.vertex_count);
        free(model->faces.vertex_indices_buffer);
        free(model->faces.vertex_indices_ptr);
        free(model->faces.z_max);
        if (model->faces.z_mean) free(model->faces.z_mean);
        free(model);
        return NULL;
    }
    
    // Initialize structure
    model->faces.vertex_countHandle = NULL;
    model->faces.vertex_indicesBufferHandle = NULL;
    model->faces.vertex_indicesPtrHandle = NULL;
    model->faces.z_maxHandle = NULL;
    model->faces.display_flagHandle = NULL;
    model->faces.sorted_face_indicesHandle = NULL;
    model->faces.total_indices = 0;
    
    // Allocate sorted_face_indices array: nf * 4 bytes = 24KB max
    model->faces.sorted_face_indices = (int*)malloc(nf * sizeof(int));
    if (!model->faces.sorted_face_indices) {
        printf("Error: Unable to allocate memory for sorted_face_indices array\n");
        keypress();
        free(model->vertices.x);
        free(model->vertices.y);
        free(model->vertices.z);
        free(model->vertices.xo);
        free(model->vertices.yo);
        free(model->vertices.zo);
        free(model->vertices.x2d);
        free(model->vertices.y2d);
        free(model->faces.vertex_count);
        free(model->faces.vertex_indices_buffer);
        free(model->faces.vertex_indices_ptr);
        if (model->faces.z_min) free(model->faces.z_min);
        if (model->faces.z_max) free(model->faces.z_max);
        if (model->faces.z_mean) free(model->faces.z_mean);
        free(model->faces.display_flag);
        free(model);
        return NULL;
    }
    
    // Initialize structure
    model->faces.vertex_countHandle = NULL;
    model->faces.vertex_indicesBufferHandle = NULL;
    model->faces.vertex_indicesPtrHandle = NULL;
    model->faces.z_maxHandle = NULL;
    model->faces.display_flagHandle = NULL;
    model->faces.sorted_face_indicesHandle = NULL;
    model->faces.total_indices = 0;
    
    return model;
}

/**
 * MEMORY CLEANUP - DESTROY MODEL 3D
 * ==================================
 * 
 * This function frees all memory allocated by createModel3D().
 * Must be called when the model is no longer needed to prevent memory leaks.
 * 
 * CLEANUP SEQUENCE:
 * 1. Free all vertex arrays (x, y, z, xo, yo, zo, x2d, y2d)
 * 2. Free all face arrays (vertex_count, vertex_indices_buffer, vertex_indices_ptr, z_max, display_flag, sorted_face_indices)
 * 3. Free main Model3D structure
 */
void destroyModel3D(Model3D* model) {
    if (model != NULL) {
        // Free all vertex arrays
        if (model->vertices.x) free(model->vertices.x);
        if (model->vertices.y) free(model->vertices.y);
        if (model->vertices.z) free(model->vertices.z);
        if (model->vertices.xo) free(model->vertices.xo);
        if (model->vertices.yo) free(model->vertices.yo);
        if (model->vertices.zo) free(model->vertices.zo);
        if (model->vertices.x2d) free(model->vertices.x2d);
        if (model->vertices.y2d) free(model->vertices.y2d);
        
        // Free all face arrays (now simplified with packed buffer)
        if (model->faces.vertex_count) free(model->faces.vertex_count);
        if (model->faces.vertex_indices_buffer) free(model->faces.vertex_indices_buffer);
        if (model->faces.vertex_indices_ptr) free(model->faces.vertex_indices_ptr);
        if (model->faces.z_max) free(model->faces.z_max);
        if (model->faces.z_mean) free(model->faces.z_mean);
        if (model->faces.z_min) free(model->faces.z_min);
        if (model->faces.z_max) free(model->faces.z_max);
        if (model->faces.plane_a) free(model->faces.plane_a);
        if (model->faces.plane_b) free(model->faces.plane_b);
        if (model->faces.plane_c) free(model->faces.plane_c);
        if (model->faces.plane_d) free(model->faces.plane_d);
        if (model->faces.minx) free(model->faces.minx);
        if (model->faces.maxx) free(model->faces.maxx);
        if (model->faces.miny) free(model->faces.miny);
        if (model->faces.maxy) free(model->faces.maxy);
        if (model->faces.display_flag) free(model->faces.display_flag);
        if (model->faces.sorted_face_indices) free(model->faces.sorted_face_indices);
        
        // Free main structure
        free(model);
    }
}

/**
 * COMPLETE 3D MODEL LOADING
 * ==========================
 * 
 * This function coordinates the complete loading of an OBJ file
 * by successively calling the vertex and face reading functions.
 * 
 * LOADING PIPELINE:
 * 1. Input parameter validation
 * 2. Read vertices from file
 * 3. Read faces from file  
 * 4. Update counters in structure
 * 
 * ERROR HANDLING:
 * - Vertex reading failure: immediate stop
 * - Face reading failure: warning but continue
 *   (vertices-only model remains usable)
 */
int loadModel3D(Model3D* model, const char* filename) {
    // Input parameter validation
    if (model == NULL || filename == NULL) {
        return -1;  // Invalid parameters
    }
    
    // Step 1: Read vertices from OBJ file
    // --- MAJ du compteur global pour la vérification des indices de faces ---
    readVertices_last_count = model->vertices.vertex_count;
    
    int vcount = readVertices(filename, &model->vertices, MAX_VERTICES);
    if (vcount < 0) {
        return -1;  // Critical failure: unable to read vertices
    }
    model->vertices.vertex_count = vcount;
    
    // Step 2: Read faces from OBJ file (using chunked allocation)
    // This function handles reading faces into 2 chunks transparently
    int fcount = readFaces_model(filename, model);
    if (fcount < 0) {
        // Critical failure: unable to read faces
        printf("\nWarning: Unable to read faces\n");
        model->faces.face_count = 0;  // No faces available
    } else {
        model->faces.face_count = fcount;
    }
    
    return 0;  // Success: model loaded (with or without faces)
}

// ============================================================================
//                    USER INTERFACE FUNCTIONS
// ============================================================================

/**
 * OBSERVER PARAMETER INPUT
 * ========================
 * 
 * This function presents a text interface to allow the
 * user to specify 3D visualization parameters.
 * 
 * REQUESTED PARAMETERS:
 * - Horizontal angle: rotation around Y-axis (left/right view)
 * - Vertical angle: rotation around X-axis (up/down view)
 * - Distance: observer distance (zoom)
 * - Screen rotation angle: final rotation in 2D plane
 * 
 * ERROR HANDLING:
 * - Default values if input failure
 * - Automatic string->Fixed32 conversion with atof() then FLOAT_TO_FIXED
 */
void getObserverParams(ObserverParams* params) {
    char input[50];  // Buffer for user input
    
    // Display section header
    printf("\nObserver parameters:\n");
    printf("============================\n");
    printf("(Press ENTER to use default values)\n");
    printf("(Enter 'debug' to see values used)\n");
    
    // Input horizontal angle (rotation around Y)
    printf("Horizontal angle (degrees, default 30): ");
    if (fgets(input, sizeof(input), stdin) != NULL) {
        // Remove newline
        input[strcspn(input, "\n")] = 0;
        if (strlen(input) == 0) {
            params->angle_h = 30;     // Default value if ENTER (degrees)
        } else {
            params->angle_h = atoi(input);  // Parse integer degrees from input
        }
    } else {
        params->angle_h = 30;         // Default value if error (degrees)
    }
    
    // Input vertical angle (rotation around X)  
    printf("Vertical angle (degrees, default 20): ");
    if (fgets(input, sizeof(input), stdin) != NULL) {
        // Remove newline
        input[strcspn(input, "\n")] = 0;
        if (strlen(input) == 0) {
            params->angle_v = 20;     // Default value if ENTER (degrees)
        } else {
            params->angle_v = atoi(input);  // Parse integer degrees from input
        }
    } else {
        params->angle_v = 20;         // Default value if error (degrees)
    }
    

    // Input screen rotation angle (final 2D rotation)
    printf("Screen rotation angle (degrees, default 0): ");
    if (fgets(input, sizeof(input), stdin) != NULL) {
        // Remove newline
        input[strcspn(input, "\n")] = 0;
        if (strlen(input) == 0) {
            params->angle_w = 0;      // Default value if ENTER (degrees)
        } else {
            params->angle_w = atoi(input);  // Parse integer degrees from input
        }
    } else {
        params->angle_w = 0;          // No rotation by default (degrees)
    }

    // Input observation distance (zoom/perspective)
    printf("Distance (default 30): ");
    if (fgets(input, sizeof(input), stdin) != NULL) {
        // Remove newline
        input[strcspn(input, "\n")] = 0;
        if (strlen(input) == 0) {
            params->distance = FLOAT_TO_FIXED(30.0);    // Default value if ENTER (Fixed Point)
        } else {
            params->distance = FLOAT_TO_FIXED(atof(input)); // String->Fixed32 conversion
        }
    } else {
        params->distance = FLOAT_TO_FIXED(30.0);        // Default distance: balanced view (Fixed Point)
    }

    // Debug: show parsed observer angles in degrees
    printf("Observer angles (degrees) - H: %d, V: %d, W: %d\n", params->angle_h, params->angle_v, params->angle_w);
}


/**
 * ULTRA-FAST FUNCTION: Combined Transformation + Projection
 * ==========================================================
 */
void processModelFast(Model3D* model, ObserverParams* params, const char* filename) {
    int i;
    Fixed32 rad_h, rad_v, rad_w;
    Fixed32 cos_h, sin_h, cos_v, sin_v, cos_w, sin_w;
    Fixed32 x, y, z, zo, xo, yo;
    Fixed32 inv_zo, x2d_temp, y2d_temp;
    
    // Direct table access - ultra-fast! (no function calls)
    cos_h = cos_deg_int(params->angle_h);
    sin_h = sin_deg_int(params->angle_h);
    cos_v = cos_deg_int(params->angle_v);
    sin_v = sin_deg_int(params->angle_v);
    cos_w = cos_deg_int(params->angle_w);
    sin_w = sin_deg_int(params->angle_w);

    // Pre-calculate all trigonometric products in Fixed32 - using 64-bit multiply
    const Fixed32 cos_h_cos_v = FIXED_MUL_64(cos_h, cos_v);
    const Fixed32 sin_h_cos_v = FIXED_MUL_64(sin_h, cos_v);
    const Fixed32 cos_h_sin_v = FIXED_MUL_64(cos_h, sin_v);
    const Fixed32 sin_h_sin_v = FIXED_MUL_64(sin_h, sin_v);
    const Fixed32 scale = FLOAT_TO_FIXED(100.0);
    const Fixed32 centre_x_f = FLOAT_TO_FIXED((float)CENTRE_X);
    const Fixed32 centre_y_f = FLOAT_TO_FIXED((float)CENTRE_Y);
    const Fixed32 distance = params->distance;
    
    // Performance measurement (timing removed)
    
    // 100% Fixed32 loop - ZERO conversions, maximum speed!
    VertexArrays3D* vtx = &model->vertices;
    
    for (i = 0; i < vtx->vertex_count; i++) {
        x = vtx->x[i];
        y = vtx->y[i];
        z = vtx->z[i];
        // 3D transformation in pure Fixed32 (64-bit multiply)
        Fixed32 term1 = FIXED_MUL_64(x, cos_h_cos_v);
        Fixed32 term2 = FIXED_MUL_64(y, sin_h_cos_v);
        Fixed32 term3 = FIXED_MUL_64(z, sin_v);
        zo = FIXED_ADD(FIXED_SUB(FIXED_SUB(FIXED_NEG(term1), term2), term3), distance);
        if (zo > 0) {
            xo = FIXED_ADD(FIXED_NEG(FIXED_MUL_64(x, sin_h)), FIXED_MUL_64(y, cos_h));
            yo = FIXED_ADD(FIXED_SUB(FIXED_NEG(FIXED_MUL_64(x, cos_h_sin_v)), FIXED_MUL_64(y, sin_h_sin_v)), FIXED_MUL_64(z, cos_v));
            vtx->zo[i] = zo;
            vtx->xo[i] = xo;
            vtx->yo[i] = yo;
            inv_zo = FIXED_DIV_64(scale, zo);
            x2d_temp = FIXED_ADD(FIXED_MUL_64(xo, inv_zo), centre_x_f);
            y2d_temp = FIXED_SUB(centre_y_f, FIXED_MUL_64(yo, inv_zo));
            vtx->x2d[i] = FIXED_ROUND_TO_INT(FIXED_ADD(FIXED_SUB(FIXED_MUL_64(cos_w, FIXED_SUB(x2d_temp, centre_x_f)), FIXED_MUL_64(sin_w, FIXED_SUB(centre_y_f, y2d_temp))), centre_x_f));
            vtx->y2d[i] = FIXED_ROUND_TO_INT(FIXED_SUB(centre_y_f, FIXED_ADD(FIXED_MUL_64(sin_w, FIXED_SUB(x2d_temp, centre_x_f)), FIXED_MUL_64(cos_w, FIXED_SUB(centre_y_f, y2d_temp)))));
        } else {
            vtx->zo[i] = zo;
            vtx->xo[i] = 0;
            vtx->yo[i] = 0;
            vtx->x2d[i] = -1;
            vtx->y2d[i] = -1;
        }
    }
    

    
    // Face sorting after transformation
    long t_start, t_end;

    t_start = GetTick();
    calculateFaceDepths(model, NULL, model->faces.face_count);
    t_end = GetTick();
    {
        long elapsed = t_end - t_start;
        double ms = ((double)elapsed * 1000.0) / 60.0; // 60 ticks per second
        printf("[TIMING] calculateFaceDepths: %ld ticks (%.2f ms)\n", elapsed, ms);
    }

    
    // CRITICAL: Reset sorted_face_indices before each sort to prevent corruption
    for (i = 0; i < model->faces.face_count; i++) {
        model->faces.sorted_face_indices[i] = i;
    }

    // painter_newell_sancha (remplace sortFacesByDepth)
    t_start = GetTick();
    painter_newell_sancha(model, model->faces.face_count);
    t_end = GetTick();

    if (!PERFORMANCE_MODE)
    {
        long elapsed = t_end - t_start;
        double ms = ((double)elapsed * 1000.0) / 60.0; // 60 ticks per second
        printf("[TIMING] painter_newell_sancha: %ld ticks (%.2f ms)\n", elapsed, ms);
        keypress();
    }
}

// ============================================================================
// ============================================================================

/**
 * VERTEX READING FROM OBJ FILE
 * ============================
 * 
 * This function parses an OBJ format file to extract
 * vertices (3D points). It searches for lines starting with "v "
 * and extracts X, Y, Z coordinates.
 * 
 * OBJ FORMAT FOR VERTICES:
 *   v 1.234 5.678 9.012
 *   v -2.5 0.0 3.14159
 * 
 * ALGORITHM:
 * 1. Open file in read mode
 * 2. Read line by line with fgets()
 * 3. Detect "v " lines with character verification
 * 4. Extract coordinates with sscanf()
 * 5. Store in array with bounds checking
 * 6. Progressive display for user feedback
 * 
 * ERROR HANDLING:
 * - File opening verification
 * - Array overflow protection
 * - Coordinate format validation
 */
int readVertices(const char* filename, VertexArrays3D* vtx, int max_vertices) {
    FILE *file;
    char line[MAX_LINE_LENGTH];
    int line_number = 1;
    int vertex_count = 0;
    
    // Open file in read mode
    file = fopen(filename, "r");
    if (file == NULL) {
        printf("[DEBUG] readVertices: fopen failed\n");
        printf("Error: Unable to open file '%s'\n", filename);
        printf("Check that the file exists and you have read permissions.\n");
        return -1;
    }
    
    printf("\nReading vertices from file...'%s':\n", filename);
    
    // Read file line by line
    while (fgets(line, sizeof(line), file) != NULL) {
        if (line[0] == 'v' && line[1] == ' ') {
            if (vertex_count < max_vertices) {
                float x, y, z;
                if (sscanf(line + 2, "%f %f %f", &x, &y, &z) == 3) {
                    vtx->x[vertex_count] = FLOAT_TO_FIXED(x);
                    vtx->y[vertex_count] = FLOAT_TO_FIXED(y);
                    vtx->z[vertex_count] = FLOAT_TO_FIXED(z);
                    vertex_count++;
                    if (vertex_count % 10 == 0) printf("..");

                } else {
                    printf("[\nDEBUG] readVertices: sscanf failed at line %d: %s\n", line_number, line);
                    keypress();
                }
            } else {
                printf("\n[DEBUG] readVertices: vertex limit reached (%d)\n", max_vertices);
                keypress();
            }
        }
        line_number++;
    }
    printf("\n");
    printf("Reading vertices finished : %d vertices read.\n", vertex_count);

    // Close file
    fclose(file);
    
    return vertex_count;
}

int readFaces_model(const char* filename, Model3D* model) {
    FILE *file;
    char line[MAX_LINE_LENGTH];
    int line_number = 1;
    int face_count = 0;
    int i;
    
    if (model == NULL || model->faces.vertex_count == NULL) {
        printf("Error: Invalid model structure for readFaces_model\n");
        return -1;
    }
    
    // Open file in read mode
    file = fopen(filename, "r");
    if (file == NULL) {
        printf("Error: Unable to open file '%s' to read faces\n", filename);
        return -1;
    }
    
    printf("\nReading faces from file '%s' :\n", filename);
    
    int buffer_pos = 0;
    
    // Read file line by line
    while (fgets(line, sizeof(line), file) != NULL) {
        if (line[0] == 'f' && line[1] == ' ') {
            if (face_count < MAX_FACES) {
                model->faces.vertex_count[face_count] = 0;
                model->faces.display_flag[face_count] = 1;
                model->faces.vertex_indices_ptr[face_count] = buffer_pos;
                
                char *ptr = line + 2;
                int temp_indices[MAX_FACE_VERTICES];
                int temp_vertex_count = 0;
                int invalid_index_found = 0;
                
                // Parse character by character
                while (*ptr != '\0' && *ptr != '\n' && temp_vertex_count < MAX_FACE_VERTICES) {
                    while (*ptr == ' ' || *ptr == '\t') ptr++;
                    
                    if (*ptr == '\0' || *ptr == '\n') break;
                    
                    int vertex_index = 0;
                    while (*ptr >= '0' && *ptr <= '9') {
                        vertex_index = vertex_index * 10 + (*ptr - '0');
                        ptr++;
                    }
                    
                    while (*ptr != '\0' && *ptr != ' ' && *ptr != '\t' && *ptr != '\n') {
                        ptr++;
                    }
                    
                    if (vertex_index >= 1) {
                        if (vertex_index > readVertices_last_count) {
                            invalid_index_found = 1;
                        }
                        temp_indices[temp_vertex_count] = vertex_index;
                        temp_vertex_count++;
                    }
                }
                
                if (invalid_index_found) {
                    printf("\nERROR: Face at line %d references vertex index > %d vertices\n", 
                           line_number, readVertices_last_count);
                    fclose(file);
                    return -1;
                } else {
                    for (i = 0; i < temp_vertex_count; i++) {
                        model->faces.vertex_indices_buffer[buffer_pos++] = temp_indices[i];
                    }
                    model->faces.vertex_count[face_count] = temp_vertex_count;
                    model->faces.total_indices += temp_vertex_count;
                    
                    if (model->faces.vertex_count[face_count] > 0) {
                        face_count++;
                        if (face_count % 10 == 0) {printf(".");}
                    } else {
                        printf("     -> WARNING: Face without valid vertices ignored\n");
                    }
                }
            } else {
                printf("     -> WARNING: Face limit reached (%d)\n", MAX_FACES);
            }
        }
        
        line_number++;
    }
    
    // Close file
    fclose(file);
    
    model->faces.face_count = face_count;
    
    for (i = 0; i < face_count; i++) {
        model->faces.sorted_face_indices[i] = i;
    }
    
    printf("\nReading faces finished : %d faces read.\n", face_count);
    return face_count;
}
/*
 * transformToObserver
 * -------------------
 * Apply the observer (camera) transformation to all model vertices.
 * Steps:
 *  1. Precompute integer-degree trigonometric values from lookup tables.
 *  2. Build combined trigonometric products to minimize repeated work.
 *  3. For each vertex (x,y,z): apply horizontal rotation (Y-axis) and
 *     vertical rotation (X-axis) using the combined terms and store
 *     the resulting observer-space coordinates (xo, yo, zo).
 *
 * Formulas (fixed-point, using 16.16 arithmetic with 64-bit intermediates):
 *  zo = -x*(cos_h*cos_v) - y*(sin_h*cos_v) - z*sin_v + distance
 *  xo = -x*sin_h + y*cos_h
 *  yo = -x*(cos_h*sin_v) - y*(sin_h*sin_v) + z*cos_v
 *
 * Rationale:
 *  - The ordering of rotations is chosen to keep numerical stability on
 *    constrained hardware and to match the original projector conventions.
 *  - All multiplications use FIXED_MUL_64 to preserve precision and avoid overflow.
 */
void transformToObserver(VertexArrays3D* vtx, int angle_h_deg, int angle_v_deg, Fixed32 distance) {
    int i;
    Fixed32 cos_h, sin_h, cos_v, sin_v;
    Fixed32 x, y, z;
    cos_h = cos_deg_int(angle_h_deg);
    sin_h = sin_deg_int(angle_h_deg);
    cos_v = cos_deg_int(angle_v_deg);
    sin_v = sin_deg_int(angle_v_deg);
    Fixed32 cos_h_cos_v = FIXED_MUL_64(cos_h, cos_v);
    Fixed32 sin_h_cos_v = FIXED_MUL_64(sin_h, cos_v);
    Fixed32 cos_h_sin_v = FIXED_MUL_64(cos_h, sin_v);
    Fixed32 sin_h_sin_v = FIXED_MUL_64(sin_h, sin_v);

    for (i = 0; i < vtx->vertex_count; i++) {
        x = vtx->x[i];
        z = vtx->z[i];
        vtx->xo[i] = FIXED_ADD(
            FIXED_MUL_64(x, cos_h_cos_v),
            FIXED_MUL_64(y, sin_h_cos_v)
        );
        vtx->yo[i] = FIXED_ADD(
            FIXED_SUB(
                FIXED_MUL_64(-x, cos_h_sin_v),
                FIXED_MUL_64(y, sin_h_sin_v)
            ),
            FIXED_MUL_64(z, cos_v)
        );
        vtx->zo[i] = FIXED_ADD(
            FIXED_ADD(
                FIXED_MUL_64(-x, sin_h),
                FIXED_MUL_64(-y, cos_h)
            ),
            distance
        );
    }
}

void projectTo2D(VertexArrays3D* vtx, int angle_w_deg) {
    int i;
    Fixed32 cos_w, sin_w;
    Fixed32 x2d_temp, y2d_temp;
    cos_w = cos_deg_int(angle_w_deg);
    sin_w = sin_deg_int(angle_w_deg);
    const Fixed32 scale = INT_TO_FIXED(100);
    const Fixed32 centre_x_f = INT_TO_FIXED(CENTRE_X);
    const Fixed32 centre_y_f = INT_TO_FIXED(CENTRE_Y);

    for (i = 0; i < vtx->vertex_count; i++) {
        if (vtx->zo[i] > 0) {
            Fixed32 xo = vtx->xo[i];
            Fixed32 yo = vtx->yo[i];
            Fixed32 inv_zo = FIXED_DIV_64(scale, vtx->zo[i]);
            x2d_temp = FIXED_ADD(FIXED_MUL_64(xo, inv_zo), centre_x_f);
            y2d_temp = FIXED_SUB(centre_y_f, FIXED_MUL_64(yo, inv_zo));
            vtx->x2d[i] = FIXED_ROUND_TO_INT(FIXED_ADD(FIXED_SUB(FIXED_MUL_64(cos_w, FIXED_SUB(x2d_temp, centre_x_f)), FIXED_MUL_64(sin_w, FIXED_SUB(centre_y_f, y2d_temp))), centre_x_f));
            vtx->y2d[i] = FIXED_ROUND_TO_INT(FIXED_SUB(centre_y_f, FIXED_ADD(FIXED_MUL_64(sin_w, FIXED_SUB(x2d_temp, centre_x_f)), FIXED_MUL_64(cos_w, FIXED_SUB(centre_y_f, y2d_temp)))));
        } else {
            vtx->x2d[i] = -1;
            vtx->y2d[i] = -1;
        }
    }
}

/**
 * CALCULATING MINIMUM FACE DEPTHS AND VISIBILITY FLAGS
 * =====================================================
 * 
 * This function calculates for each face:
 * 1. The minimum depth (z_min) of all its vertices in the observer coordinate system
 * 2. The display visibility flag based on vertex positions relative to camera
 * 
 * The z_min value is used for face sorting during rendering (painter's algorithm).

 * We use minimum (closest point) for correct occlusion in the painter's algorithm.
 * The display_flag is used to cull faces that have vertices behind the camera.
 * 
 * PARAMETERS:
 *   vertices   : Array of vertices with coordinates in observer system
 *   faces      : Array of faces to process  
 *   face_count : Number of faces
 * 
 * ALGORITHM:
 *   For each face:
 *   - Initialize z_min with very large value (9999.0)
 *   - Initialize display_flag as true (displayable)
 *   - For each vertex of the face:
 *     * Check if vertex is behind camera (zo <= 0)
 *     * If ANY vertex is behind camera, set display_flag = false
 *     * Update z_min with minimum zo value found (closest vertex)
 *   - Store both z_min and display_flag in the face structure
 * 
 * CULLING LOGIC:
 *   - If ANY vertex has zo <= 0, the entire face is marked as non-displayable
 *   - This prevents rendering artifacts from perspective projection errors
 *   - Improves performance by eliminating faces early in the pipeline
 * 
 * NOTES:
 *   - Must be called AFTER transformToObserver() or processModelFast()
 *   - Uses zo coordinates (observer system depth)
 *   - Lower z_min value means face is closer to camera (should draw first in painter's algorithm)
 *   - display_flag = 1 means visible, 0 means hidden (behind camera)
 */
void calculateFaceDepths(Model3D* model, Face3D* faces, int face_count) {
    int i, j;
    VertexArrays3D* vtx = &model->vertices;
    FaceArrays3D* face_arrays = &model->faces;
    
    for (i = 0; i < face_count; i++) {
        Fixed32 z_min = FLOAT_TO_FIXED(9999.0);
        Fixed32 z_max = FLOAT_TO_FIXED(-9999.0);
        int display_flag = 1;
        Fixed32 sum = 0;
        int n = face_arrays->vertex_count[i];
        int minx = 9999, maxx = -9999, miny = 9999, maxy = -9999;
        
        int offset = face_arrays->vertex_indices_ptr[i];
        for (j = 0; j < n; j++) {
            int vertex_idx = face_arrays->vertex_indices_buffer[offset + j] - 1;
            if (vertex_idx >= 0) {
                Fixed32 zo = vtx->zo[vertex_idx];
                if (zo <= 0) display_flag = 0;
                if (zo < z_min) z_min = zo;
                if (zo > z_max) z_max = zo;
                sum += zo;
                int x2d = vtx->x2d[vertex_idx];
                int y2d = vtx->y2d[vertex_idx];
                if (x2d < minx) minx = x2d;
                if (x2d > maxx) maxx = x2d;
                if (y2d < miny) miny = y2d;
                if (y2d > maxy) maxy = y2d;
            }
        }
        Fixed32 a = 0, b = 0, c = 0, d = 0;
        if (n > 0) {
            for (j = 0; j < n; j++) {
                int idx1 = face_arrays->vertex_indices_buffer[offset + j] - 1;
                int idx2 = face_arrays->vertex_indices_buffer[offset + ((j+1)%n)] - 1;
                if (idx1 >= 0 && idx2 >= 0) {
                    Fixed32 x1 = vtx->xo[idx1], y1 = vtx->yo[idx1], z1 = vtx->zo[idx1];
                    Fixed32 x2 = vtx->xo[idx2], y2 = vtx->yo[idx2], z2 = vtx->zo[idx2];
                    a += (y1 - y2) * (z1 + z2);
                    b += (z1 - z2) * (x1 + x2);
                    c += (x1 - x2) * (y1 + y2);
                }
            }
            Fixed32 len_sq = a*a + b*b + c*c;
            Fixed32 min_length_sq = FLOAT_TO_FIXED(0.01);
            if (len_sq < min_length_sq) {
                face_arrays->plane_a[i] = 0;
                face_arrays->plane_b[i] = 0;
                face_arrays->plane_c[i] = 0;
                face_arrays->plane_d[i] = 0;
            } else {
                Fixed32 len = FLOAT_TO_FIXED(sqrt(FIXED_TO_FLOAT(len_sq)));
                a = FIXED_DIV(a, len);
                b = FIXED_DIV(b, len);
                c = FIXED_DIV(c, len);
                int v0 = face_arrays->vertex_indices_buffer[offset] - 1;
                if (v0 >= 0) {
                    d = FIXED_NEG(FIXED_ADD(FIXED_ADD(FIXED_MUL_64(a, vtx->xo[v0]), FIXED_MUL_64(b, vtx->yo[v0])), FIXED_MUL_64(c, vtx->zo[v0])));
                } else d = 0;
                face_arrays->plane_a[i] = a;
                face_arrays->plane_b[i] = b;
                face_arrays->plane_c[i] = c;
                face_arrays->plane_d[i] = d;
            }
        } else {
            face_arrays->plane_a[i] = 0;
            face_arrays->plane_b[i] = 0;
            face_arrays->plane_c[i] = 0;
            face_arrays->plane_d[i] = 0;
        }

        face_arrays->z_min[i] = z_min;
        face_arrays->z_max[i] = z_max;
        face_arrays->display_flag[i] = display_flag;
        if (n > 0) {
            face_arrays->z_mean[i] = sum / n;
            face_arrays->minx[i] = minx;
            face_arrays->maxx[i] = maxx;
            face_arrays->miny[i] = miny;
            face_arrays->maxy[i] = maxy;
        } else {
            face_arrays->z_mean[i] = 0;
            face_arrays->z_min[i] = 0;
            face_arrays->z_max[i] = 0;
            face_arrays->minx[i] = 0;
            face_arrays->maxx[i] = 0;
            face_arrays->miny[i] = 0;
            face_arrays->maxy[i] = 0;
        }
    }
}


#define SWAP_FACE(faces, i, j) \
    do { \
        int temp_idx = faces->sorted_face_indices[i]; \
        faces->sorted_face_indices[i] = faces->sorted_face_indices[j]; \
        faces->sorted_face_indices[j] = temp_idx; \
    } while (0)


// Function to draw polygons with QuickDraw
void drawPolygons(Model3D* model, int* vertex_count, int face_count, int vertex_count_total) {
    int i, j;
    VertexArrays3D* vtx = &model->vertices;
    FaceArrays3D* faces = &model->faces;
    Handle polyHandle;
    DynamicPolygon *poly;
    int min_x, max_x, min_y, max_y;
    int valid_faces_drawn = 0;
    int invalid_faces_skipped = 0;
    int triangle_count = 0;
    int quad_count = 0;
    Pattern pat;
    
    if (globalPolyHandle == NULL) {
        int max_polySize = 2 + 8 + (4 * 4);
        globalPolyHandle = NewHandle((long)max_polySize, userid(), 0xC014, 0L);
        if (globalPolyHandle == NULL) {
            printf("Error: Unable to allocate global polygon handle\n");
            return;
        }
    }
    
    polyHandle = globalPolyHandle;
    
    if (poly_handle_locked) {
        HUnlock(polyHandle);
        poly_handle_locked = 0;
    }
    HLock(polyHandle);
    poly_handle_locked = 1;

    SetPenMode(0);

    // Use sorted_face_indices to draw in correct depth order
    int start_face = 0;
    int max_faces_to_draw = face_count;
    for (i = start_face; i < start_face + max_faces_to_draw; i++) {
        int face_id = faces->sorted_face_indices[i];
        if (faces->display_flag[face_id] == 0) continue;
        if (faces->vertex_count[face_id] >= 3) {
            int offset = faces->vertex_indices_ptr[face_id];

            // Calculate polySize for this specific face
            int polySize = 2 + 8 + (faces->vertex_count[face_id] * 4);
            poly = (DynamicPolygon *)*polyHandle;
            poly->polySize = polySize;
            min_x = max_x = min_y = max_y = -1;
            for (j = 0; j < faces->vertex_count[face_id]; j++) {
                int vertex_idx = faces->vertex_indices_buffer[offset + j] - 1;
                // Only draw valid vertices
                if (vertex_idx >= 0 && vertex_idx < vtx->vertex_count) {
                    poly->polyPoints[j].h = mode / 320 * vtx->x2d[vertex_idx];
                    poly->polyPoints[j].v = vtx->y2d[vertex_idx];
                    if (min_x == -1 || vtx->x2d[vertex_idx] < min_x) min_x = vtx->x2d[vertex_idx];
                    if (max_x == -1 || vtx->x2d[vertex_idx] > max_x) max_x = vtx->x2d[vertex_idx];
                    if (min_y == -1 || vtx->y2d[vertex_idx] < min_y) min_y = vtx->y2d[vertex_idx];
                    if (max_y == -1 || vtx->y2d[vertex_idx] > max_y) max_y = vtx->y2d[vertex_idx];
                }
            }
            poly->polyBBox.h1 = min_x;
            poly->polyBBox.v1 = min_y;
            poly->polyBBox.h2 = max_x;
            poly->polyBBox.v2 = max_y;
            SetSolidPenPat(14);
            GetPenPat(pat);
            FillPoly(polyHandle, pat);
            SetSolidPenPat(7);
            FramePoly(polyHandle);
            valid_faces_drawn++;
            if (faces->vertex_count[face_id] == 3) triangle_count++;
            else if (faces->vertex_count[face_id] == 4) quad_count++;
        } else {
            invalid_faces_skipped++;
        }
    }
    // Print statistics after drawing
//     printf("Display statistics: %d valid faces drawn, %d invalid faces skipped\n", valid_faces_drawn, invalid_faces_skipped);
//     printf("Triangles: %d, Quads: %d\n", triangle_count, quad_count);
}

void DoColor() {
        Rect r;
        unsigned char pstr[4];  // Pascal string: [length][characters...]]

        SetRect (&r, 0, 1, mode / 320 *10, 11);
        for (int i = 0; i < 16; i++) {
            SetSolidPenPat(i);
            PaintRect(&r);

            if (i == 0) {
                SetSolidPenPat(15); // White frame for black background
                FrameRect(&r);
            }

            MoveTo(r.h1, r.v2+10);
            // Create a Pascal string to display the number
            if (i < 10) {
                pstr[0] = 1;           // Length: 1 character
                pstr[1] = '0' + i;     // Digit 0-9
            } else {
                pstr[0] = 2;           // Length: 2 characters
                pstr[1] = '0' + (i / 10);      // Tens (1 for 10-15)
                pstr[2] = '0' + (i % 10);      // Units (0-5 for 10-15)
            }
            DrawString(pstr);
            OffsetRect(&r, 20, 0);
        }
}

void DoText() {
        shroff();
        putchar((char) 12); // Clear screen    
}
    int main() {
        Model3D* model;
        ObserverParams params;
        char filename[100];
        char input[50];
        int colorpalette = 0; // default color palette

    newmodel:
        printf("===================================\n");
        printf("       3D OBJ file viewer\n");
        printf("===================================\n\n");

        // Creer le modele 3D
        model = createModel3D();
        if (model == NULL) {
            printf("Error: Unable to allocate memory for 3D model\n");
            printf("Press any key to quit...\n");
            keypress();
            return 1;
        }

        // Ask for filename
        printf("Enter the filename to read: ");
        if (fgets(filename, sizeof(filename), stdin) != NULL) {
            size_t len = strlen(filename);
            if (len > 0 && filename[len-1] == '\n') {
                filename[len-1] = '\0';
            }
        }

        // Charger le modele 3D
        if (loadModel3D(model, filename) < 0) {
            printf("\nError loading file\n");
            printf("Press any key to quit...\n");
            keypress();
            destroyModel3D(model);
            return 1;
        }

        // Get observer parameters
        getObserverParams(&params);

    bigloop:
        // Process model with parameters - OPTIMIZED VERSION
        printf("Processing model...\n");
        processModelFast(model, &params, filename);

    loopReDraw:
        {
            int key = 0;
            char input[50];

            if (model->faces.face_count > 0) {
                // Initialize QuickDraw
                startgraph(mode);
                // Draw 3D object
                drawPolygons(model, model->faces.vertex_count, model->faces.face_count, model->vertices.vertex_count);
                // display available colors
                if (colorpalette == 1) { 
                    DoColor(); 
                }

                // Wait for key press and get key code
        asm 
            {
            sep #0x20
        loop:
            lda >0xC000     // Read the keyboard status from memory address 0xC000
            bpl loop        // Wait until no key is pressed (= until bit 7 on)
            and #0x007f     // Clear the high bit
            sta >0xC010     // Clear the keypress by writing to 0xC010
            sta key         // Store the key code in variable 'key'
            rep #0x30
            }

        endgraph();        // Close QuickDraw
        }

        DoText();           // Show text screen

    #if ENABLE_DEBUG_SAVE
        sprintf(input, "You pressed key code: %d\n", key);
        printf("%s", input);
    #endif

        // Handle keyboard input with switch statement
        switch (key) {
            case 32:  // Space bar - display info and redraw
                printf("===================================\n");
                printf(" Model information and parameters\n");
                printf("===================================\n");
                printf("Model: %s\n", filename);
                printf("Vertices: %d, Faces: %d\n", model->vertices.vertex_count, model->faces.face_count);
                printf("Observer Parameters:\n");
                printf("    Distance: %.2f\n", FIXED_TO_FLOAT(params.distance));
                printf("    Horizontal Angle: %d°\n", params.angle_h);
                printf("    Vertical Angle: %d°\n", params.angle_v);
                printf("    Screen Rotation Angle: %d°\n", params.angle_w);
                printf("===================================\n");
                printf("\n");
                printf("Press any key to continue...\n");
                keypress();
                goto loopReDraw;

            case 65:  // 'A' - decrease distance
            case 97:  // 'a'
                params.distance = params.distance - (params.distance / 10);
                goto bigloop;

            case 90:  // 'Z' - increase distance  
            case 122: // 'z'
                params.distance = params.distance + (params.distance / 10);
                goto bigloop;

            case 21:  // Right arrow - increase horizontal angle
                params.angle_h = normalize_deg(params.angle_h + 10);
                goto bigloop;

            case 8:   // Left arrow - decrease horizontal angle
                params.angle_h = normalize_deg(params.angle_h - 10);
                goto bigloop;

            case 10:  // Down arrow - decrease vertical angle
                params.angle_v = normalize_deg(params.angle_v - 10);
                goto bigloop;

            case 11:  // Up arrow - increase vertical angle
                params.angle_v = normalize_deg(params.angle_v + 10);
                goto bigloop;

            case 87:  // 'W' - increase screen rotation angle
            case 119: // 'w'
                params.angle_w = normalize_deg(params.angle_w + 10);
                goto bigloop;

            case 88:  // 'X' - decrease screen rotation angle
            case 120: // 'x'
                params.angle_w = normalize_deg(params.angle_w - 10);
                goto bigloop;
        
            case 67:  // 'C' - toggle color palette display
            case 99:  // 'c'
                colorpalette ^= 1; // Toggle between 0 and 1
                goto loopReDraw;

            case 78:  // 'N' - load new model
            case 110: // 'n'
                destroyModel3D(model);
                goto newmodel;
        
            // dispaly help
            case 72:  // 'H'
            case 104: // 'h'
                printf("===================================\n");
                printf("    HELP - Keyboard Controller\n");
                printf("===================================\n\n");
                printf("Space: Display model info\n");
                printf("A/Z: Increase/Decrease distance\n");
                printf("Arrow Left/Right: Decrease/Increase horizontal angle\n");
                printf("Arrow Up/Down: Increase/Decrease vertical angle\n");
                printf("W/X: Increase/Decrease screen rotation angle\n");
                printf("C: Toggle color palette display\n");
                printf("N: Load new model\n");
                printf("H: Display this help message\n");
                printf("ESC: Quit program\n");
                printf("===================================\n");
                printf("\n");
                printf("Press any key to continue...\n");
                keypress();
                goto loopReDraw;

            case 27:  // ESC - quit
                goto end;
            
            default:  // All other keys - redraw
                goto loopReDraw;
        }
        }  // End of loopReDraw block

        end:
        // Cleanup and exit
        // Dispose of the global polygon handle if it was allocated
        if (globalPolyHandle != NULL) {
            if (poly_handle_locked) {
                HUnlock(globalPolyHandle);
            }
            DisposeHandle(globalPolyHandle);
            globalPolyHandle = NULL;
        }
        destroyModel3D(model);
        return 0;
    }