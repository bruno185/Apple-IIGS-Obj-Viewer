



#include <stdio.h>
#include <asm.h>
#include <string.h>
#include <misctool.h>
#include <stdlib.h>
#include <math.h>
#include <quickdraw.h>
#include <event.h>
#include <memory.h>
#include <window.h>
#include <orca.h>

int readVertices_last_count = 0;

static Handle globalPolyHandle = NULL;
static int poly_handle_locked = 0;





typedef long Fixed32;           
typedef long long Fixed64;      

#define FIXED_SHIFT     16
#define FIXED_SCALE     (1L << FIXED_SHIFT)
#define FIXED_MASK      (FIXED_SCALE - 1)
#define FIXED_HALF      (FIXED_SCALE >> 1)


#define FIXED_PI        205887L
#define FIXED_2PI       411775L
#define FIXED_PI_2      102944L
#define FIXED_ONE       FIXED_SCALE
#define FIXED_PI_180    1143LL




static const Fixed32 sin_table[360] = {
    0, 1144, 2287, 3430, 4572, 5712, 6850, 7987, 9121, 10252,
    11380, 12505, 13626, 14742, 15855, 16962, 18064, 19161, 20252, 21336,
    22415, 23486, 24550, 25607, 26656, 27697, 28729, 29753, 30767, 31772,
    32768, 33754, 34729, 35693, 36647, 37590, 38521, 39441, 40348, 41243,
    42126, 42995, 43852, 44695, 45525, 46341, 47143, 47930, 48703, 49461,
    50203, 50931, 51643, 52339, 53020, 53684, 54332, 54963, 55578, 56175,
    56756, 57319, 57865, 58393, 58903, 59396, 59870, 60326, 60764, 61183,
    61584, 61966, 62328, 62672, 62997, 63303, 63589, 63856, 64104, 64332,
    64540, 64729, 64898, 65048, 65177, 65287, 65376, 65446, 65496, 65526,
    65536, 65526, 65496, 65446, 65376, 65287, 65177, 65048, 64898, 64729,
    64540, 64332, 64104, 63856, 63589, 63303, 62997, 62672, 62328, 61966,
    61584, 61183, 60764, 60326, 59870, 59396, 58903, 58393, 57865, 57319,
    56756, 56175, 55578, 54963, 54332, 53684, 53020, 52339, 51643, 50931,
    50203, 49461, 48703, 47930, 47143, 46341, 45525, 44695, 43852, 42995,
    42126, 41243, 40348, 39441, 38521, 37590, 36647, 35693, 34729, 33754,
    32768, 31772, 30767, 29753, 28729, 27697, 26656, 25607, 24550, 23486,
    22415, 21336, 20252, 19161, 18064, 16962, 15855, 14742, 13626, 12505,
    11380, 10252, 9121, 7987, 6850, 5712, 4572, 3430, 2287, 1144,
    0, -1144, -2287, -3430, -4572, -5712, -6850, -7987, -9121, -10252,
    -11380, -12505, -13626, -14742, -15855, -16962, -18064, -19161, -20252, -21336,
    -22415, -23486, -24550, -25607, -26656, -27697, -28729, -29753, -30767, -31772,
    -32768, -33754, -34729, -35693, -36647, -37590, -38521, -39441, -40348, -41243,
    -42126, -42995, -43852, -44695, -45525, -46341, -47143, -47930, -48703, -49461,
    -50203, -50931, -51643, -52339, -53020, -53684, -54332, -54963, -55578, -56175,
    -56756, -57319, -57865, -58393, -58903, -59396, -59870, -60326, -60764, -61183,
    -61584, -61966, -62328, -62672, -62997, -63303, -63589, -63856, -64104, -64332,
    -64540, -64729, -64898, -65048, -65177, -65287, -65376, -65446, -65496, -65526,
    -65536, -65526, -65496, -65446, -65376, -65287, -65177, -65048, -64898, -64729,
    -64540, -64332, -64104, -63856, -63589, -63303, -62997, -62672, -62328, -61966,
    -61584, -61183, -60764, -60326, -59870, -59396, -58903, -58393, -57865, -57319,
    -56756, -56175, -55578, -54963, -54332, -53684, -53020, -52339, -51643, -50931,
    -50203, -49461, -48703, -47930, -47143, -46341, -45525, -44695, -43852, -42995,
    -42126, -41243, -40348, -39441, -38521, -37590, -36647, -35693, -34729, -33754,
    -32768, -31772, -30767, -29753, -28729, -27697, -26656, -25607, -24550, -23486,
    -22415, -21336, -20252, -19161, -18064, -16962, -15855, -14742, -13626, -12505,
    -11380, -10252, -9121, -7987, -6850, -5712, -4572, -3430, -2287, -1144,
};
static const Fixed32 cos_table[360] = {
    65536, 65526, 65496, 65446, 65376, 65287, 65177, 65048, 64898, 64729,
    64540, 64332, 64104, 63856, 63589, 63303, 62997, 62672, 62328, 61966,
    61584, 61183, 60764, 60326, 59870, 59396, 58903, 58393, 57865, 57319,
    56756, 56175, 55578, 54963, 54332, 53684, 53020, 52339, 51643, 50931,
    50203, 49461, 48703, 47930, 47143, 46341, 45525, 44695, 43852, 42995,
    42126, 41243, 40348, 39441, 38521, 37590, 36647, 35693, 34729, 33754,
    32768, 31772, 30767, 29753, 28729, 27697, 26656, 25607, 24550, 23486,
    22415, 21336, 20252, 19161, 18064, 16962, 15855, 14742, 13626, 12505,
    11380, 10252, 9121, 7987, 6850, 5712, 4572, 3430, 2287, 1144,
    0, -1144, -2287, -3430, -4572, -5712, -6850, -7987, -9121, -10252,
    -11380, -12505, -13626, -14742, -15855, -16962, -18064, -19161, -20252, -21336,
    -22415, -23486, -24550, -25607, -26656, -27697, -28729, -29753, -30767, -31772,
    -32768, -33754, -34729, -35693, -36647, -37590, -38521, -39441, -40348, -41243,
    -42126, -42995, -43852, -44695, -45525, -46341, -47143, -47930, -48703, -49461,
    -50203, -50931, -51643, -52339, -53020, -53684, -54332, -54963, -55578, -56175,
    -56756, -57319, -57865, -58393, -58903, -59396, -59870, -60326, -60764, -61183,
    -61584, -61966, -62328, -62672, -62997, -63303, -63589, -63856, -64104, -64332,
    -64540, -64729, -64898, -65048, -65177, -65287, -65376, -65446, -65496, -65526,
    -65536, -65526, -65496, -65446, -65376, -65287, -65177, -65048, -64898, -64729,
    -64540, -64332, -64104, -63856, -63589, -63303, -62997, -62672, -62328, -61966,
    -61584, -61183, -60764, -60326, -59870, -59396, -58903, -58393, -57865, -57319,
    -56756, -56175, -55578, -54963, -54332, -53684, -53020, -52339, -51643, -50931,
    -50203, -49461, -48703, -47930, -47143, -46341, -45525, -44695, -43852, -42995,
    -42126, -41243, -40348, -39441, -38521, -37590, -36647, -35693, -34729, -33754,
    -32768, -31772, -30767, -29753, -28729, -27697, -26656, -25607, -24550, -23486,
    -22415, -21336, -20252, -19161, -18064, -16962, -15855, -14742, -13626, -12505,
    -11380, -10252, -9121, -7987, -6850, -5712, -4572, -3430, -2287, -1144,
    0, 1144, 2287, 3430, 4572, 5712, 6850, 7987, 9121, 10252,
    11380, 12505, 13626, 14742, 15855, 16962, 18064, 19161, 20252, 21336,
    22415, 23486, 24550, 25607, 26656, 27697, 28729, 29753, 30767, 31772,
    32768, 33754, 34729, 35693, 36647, 37590, 38521, 39441, 40348, 41243,
    42126, 42995, 43852, 44695, 45525, 46341, 47143, 47930, 48703, 49461,
    50203, 50931, 51643, 52339, 53020, 53684, 54332, 54963, 55578, 56175,
    56756, 57319, 57865, 58393, 58903, 59396, 59870, 60326, 60764, 61183,
    61584, 61966, 62328, 62672, 62997, 63303, 63589, 63856, 64104, 64332,
    64540, 64729, 64898, 65048, 65177, 65287, 65376, 65446, 65496, 65526,
};


static inline Fixed32 sin_deg(Fixed32 angle) {
    int deg = (int)(angle >> FIXED_SHIFT);
    deg %= 360; if (deg < 0) deg += 360;
    return sin_table[deg];
}
static inline Fixed32 cos_deg(Fixed32 angle) {
    int deg = (int)(angle >> FIXED_SHIFT);
    deg %= 360; if (deg < 0) deg += 360;
    return cos_table[deg];
}


static inline Fixed32 sin_deg_int(int deg) {
    deg %= 360;
    if (deg < 0) deg += 360;
    return sin_table[deg];
}
static inline Fixed32 cos_deg_int(int deg) {
    deg %= 360;
    if (deg < 0) deg += 360;
    return cos_table[deg];
}


#define INT_TO_FIXED(x)     ((Fixed32)(x) << FIXED_SHIFT)
#define FIXED_TO_INT(x)     ((int)((x) >> FIXED_SHIFT))

static inline int FIXED_ROUND_TO_INT(Fixed32 x) {
    if (x >= 0) return (int)(((x) + FIXED_HALF) >> FIXED_SHIFT);
    else return (int)(((x) - FIXED_HALF) >> FIXED_SHIFT);
}
#define FLOAT_TO_FIXED(x)   ((Fixed32)((x) * FIXED_SCALE))
#define FIXED_TO_FLOAT(x)   ((float)(x) / (float)FIXED_SCALE)


#define FIXED_ADD(a, b)     ((a) + (b))
#define FIXED_SUB(a, b)     ((a) - (b))
#define FIXED_NEG(x)        (-(x))
#define FIXED_ABS(x)        ((x) >= 0 ? (x) : -(x))
#define FIXED_FRAC(x)       ((x) & FIXED_MASK)


#define FIXED_MUL(a, b)     (((long)(a) * (long)(b)) >> FIXED_SHIFT)
#define FIXED_DIV(a, b)     (((long)(a) << FIXED_SHIFT) / (long)(b))


#define FIXED_MUL_64(a, b)  ((Fixed32)(((Fixed64)(a) * (Fixed64)(b)) >> FIXED_SHIFT))
#define FIXED_DIV_64(a, b)  ((Fixed32)(((Fixed64)(a) << FIXED_SHIFT) / (Fixed64)(b)))
#define FIXED64_TO_32(x)    ((Fixed32)(x))




static inline int normalize_deg(int deg) {
    deg %= 360;
    if (deg < 0) deg += 360;
    return deg;
}




#define ENABLE_DEBUG_SAVE 0


#define PERFORMANCE_MODE 0

#define MAX_LINE_LENGTH 256
#define MAX_VERTICES 6000
#define MAX_FACES 6000
#define MAX_FACE_VERTICES 6
#define PI 3.14159265359
#define CENTRE_X 160
#define CENTRE_Y 100

#define mode 320







typedef struct {
    Handle xHandle, yHandle, zHandle;
    Handle xoHandle, yoHandle, zoHandle;
    Handle x2dHandle, y2dHandle;
    Fixed32 *x, *y, *z;
    Fixed32 *xo, *yo, *zo;
    int *x2d, *y2d;
    int vertex_count;
} VertexArrays3D;


typedef struct {
    Handle vertex_countHandle;
    Handle vertex_indicesBufferHandle;
    Handle vertex_indicesPtrHandle;
    Handle z_maxHandle;
    Handle display_flagHandle;
    Handle sorted_face_indicesHandle;
    
    int *vertex_count;
    int *vertex_indices_buffer;
    int *vertex_indices_ptr;
    Fixed32 *z_min;
    Fixed32 *z_max;
    Fixed32 *z_mean;
    Fixed32 *plane_a;
    Fixed32 *plane_b;
    Fixed32 *plane_c;
    Fixed32 *plane_d;
    int *minx;
    int *maxx;
    int *miny;
    int *maxy;
    int *display_flag;
    int *sorted_face_indices;
    int face_count;
    int total_indices;
} FaceArrays3D;


typedef struct {
    int vertex_count;
    int vertex_indices[MAX_FACE_VERTICES];
    Fixed32 z_max;
    int display_flag;
} Face3D;


typedef struct {
    int polySize;
    Rect polyBBox;
    Point polyPoints[MAX_FACE_VERTICES];
} DynamicPolygon;


 *   - Angles are in degrees (converted to radians for calculations)
 *   - Distance affects perspective and apparent size
 *   - angle_w allows final rotation to adjust orientation
 */
typedef struct {
    int angle_h;
    int angle_v;
    int angle_w;
    Fixed32 distance;
} ObserverParams;


typedef struct {
    VertexArrays3D vertices;          
    FaceArrays3D faces;               
} Model3D;




Fixed32 sin_fixed(Fixed32 angle);
Fixed32 cos_fixed(Fixed32 angle);







void transformToObserver(VertexArrays3D* vtx, int angle_h_deg, int angle_v_deg, Fixed32 distance);



void projectTo2D(VertexArrays3D* vtx, int angle_w_deg);




void drawPolygons(Model3D* model, int* vertex_count, int face_count, int vertex_count_total);

void calculateFaceDepths(Model3D* model, Face3D* faces, int face_count);





static FaceArrays3D* qsort_faces_ptr_for_cmp = NULL;
static int cmp_faces_by_zmean(const void* pa, const void* pb) {
    int a = *(const int*)pa;
    int b = *(const int*)pb;
    Fixed32 za = qsort_faces_ptr_for_cmp->z_mean[a];
    Fixed32 zb = qsort_faces_ptr_for_cmp->z_mean[b];
    if (za > zb) return -1;   
    if (za < zb) return 1;
    if (a < b) return -1;     
    if (a > b) return 1;
    return 0;
}


void painter_newell_sancha(Model3D* model, int face_count) {
    
    FaceArrays3D* faces = &model->faces;
    VertexArrays3D* vtx = &model->vertices;
    int i, j;
    Fixed32* face_zmean = faces->z_mean;
    if (!face_zmean) return;


    long t_start = GetTick();
    for (i = 0; i < face_count; i++) faces->sorted_face_indices[i] = i;
    qsort_faces_ptr_for_cmp = faces;
    qsort(faces->sorted_face_indices, face_count, sizeof(int), cmp_faces_by_zmean);
    qsort_faces_ptr_for_cmp = NULL;
    long t_end = GetTick();
    if (!PERFORMANCE_MODE)
    {
        long elapsed = t_end - t_start;
            double ms = ((double)elapsed * 1000.0) / 60.0;
    
    
    int swapped;
    int swap_count = 0;


    
    typedef struct {
        int face1;  
        int face2;  
    } OrderedPair;
    
    
    
    int ordered_pairs_capacity = face_count * 4;
    OrderedPair* ordered_pairs = NULL;
    if (ordered_pairs_capacity > 0) {
        ordered_pairs = (OrderedPair*)malloc(ordered_pairs_capacity * sizeof(OrderedPair));
        if (!ordered_pairs) {
            
            ordered_pairs_capacity = 0;
        }
    }
    int ordered_pairs_count = 0;
    
    do {
        swapped = 0;

        for (i = 0; i < face_count-1; i++) {
            int f1 = faces->sorted_face_indices[i];
            int f2 = faces->sorted_face_indices[i+1];
            
            
            
            int already_ordered = 0;
            int p;
            for (p = 0; p < ordered_pairs_count; p++) {
                if (ordered_pairs[p].face1 == f1 && ordered_pairs[p].face2 == f2) {
                    already_ordered = 1;
                    break;
                }
            }
            if (already_ordered) {
                continue;
            }

            

            
            if (faces->z_max[f2] >= faces->z_min[f1]) continue;
            
            
            
            int minx1 = faces->minx[f1], maxx1 = faces->maxx[f1], miny1 = faces->miny[f1], maxy1 = faces->maxy[f1];
            int minx2 = faces->minx[f2], maxx2 = faces->maxx[f2], miny2 = faces->miny[f2], maxy2 = faces->maxy[f2];
        
            

            if (maxx1 < minx2 || maxx2 < minx1) continue;
            
            

            if (maxy1 < miny2 || maxy2 < miny1) continue;

            
            int n1 = faces->vertex_count[f1];
            int n2 = faces->vertex_count[f2];
            int offset1 = faces->vertex_indices_ptr[f1];
            int offset2 = faces->vertex_indices_ptr[f2];
            int k;
            Fixed32 a1 = faces->plane_a[f1];
            Fixed32 b1 = faces->plane_b[f1];
            Fixed32 c1 = faces->plane_c[f1];
            Fixed32 d1 = faces->plane_d[f1];
            Fixed32 a2 = faces->plane_a[f2];
            Fixed32 b2 = faces->plane_b[f2];
            Fixed32 c2 = faces->plane_c[f2];
            Fixed32 d2 = faces->plane_d[f2];
            Fixed32 epsilon = FLOAT_TO_FIXED(0.01);

            int obs_side1 = 0; 
            int obs_side2 = 0; 
            int side;           
            int all_same_side; 
            int all_opposite_side; 
            Fixed32 test_value;


            

            

            
            obs_side1 = 0; 
            if (d1 > epsilon) obs_side1 = 1; 
            else if (d1 < -epsilon) obs_side1 = -1;
            else goto skipT4; 
            all_same_side = 1;
            for (k=0; k<n2; k++) {
                    int v = faces->vertex_indices_buffer[offset2+k]-1;
                    test_value = a1*vtx->xo[v] + b1*vtx->yo[v] + c1*vtx->zo[v] + d1;
                    if  (test_value > epsilon) side = 1;
                    else if (test_value < -epsilon) side = -1;
                    if (obs_side1 != side) { 
                        
                        
                        all_same_side = 0;   
                        break; 
                    }
            }
            if (all_same_side) continue; 

            skipT4:

            

            
            obs_side2 = 0; 
            if (d2 > epsilon) obs_side2 = 1; 
            else if (d2 < -epsilon) obs_side2 = -1;
            else goto skipT5; 
            all_opposite_side = 1;
            for (k=0; k<n1; k++) {
                int v = faces->vertex_indices_buffer[offset1+k]-1;
                test_value = a2*vtx->xo[v] + b2*vtx->yo[v] + c2*vtx->zo[v] + d2;
                if  (test_value > epsilon) side = 1;
                else if (test_value < -epsilon) side = -1;
                if (obs_side2 == side) {
                    
                    
                    all_opposite_side = 0; 
                    break; }
                }
                if (all_opposite_side) continue; 
            
            skipT5:

            

            
            obs_side1 = 0; 
            if (d1 > epsilon) obs_side1 = 1; 
            else if (d1 < -epsilon) obs_side1 = -1;
            else goto skipT6; 

                all_opposite_side = 1;
                for (k=0; k<n2; k++) {
                    int v = faces->vertex_indices_buffer[offset2+k]-1;
                    int side;
                    if  ((a1*vtx->xo[v] + b1*vtx->yo[v] + c1*vtx->zo[v] + d1) > epsilon) side = 1;
                    else side = -1;
                    if (obs_side1 == side) { 
                        all_opposite_side = 0; 
                        break; 
                        }
                }
                if (all_opposite_side == 0) continue;
                

                
                
                else {
                    goto do_swap;
                }

            skipT6: ;

            

            
            obs_side2 = 0; 
            if (d2 > epsilon) obs_side2 = 1; 
            else if (d2 < -epsilon) obs_side2 = -1;
            else goto skipT7; 
            all_same_side = 1;
            for (k=0; k<n1; k++) {
                int v = faces->vertex_indices_buffer[offset1+k]-1;
                int side;
                if  ((a2*vtx->xo[v] + b2*vtx->yo[v] + c2*vtx->zo[v] + d2) > epsilon) side = 1;
                else side = -1;
                if (obs_side2 != side) { 
                    all_same_side = 0; 
                    break; 
                    }
            }
                if (all_same_side == 0) continue;
                
                
                else {
                    goto do_swap;
                }

            do_swap: {

                int tmp = faces->sorted_face_indices[i];
                faces->sorted_face_indices[i] = faces->sorted_face_indices[i+1];
                faces->sorted_face_indices[i+1] = tmp;
                swapped = 1;
                swap_count++;
                
                
                
                
                if (ordered_pairs != NULL && ordered_pairs_count < ordered_pairs_capacity) {
                    ordered_pairs[ordered_pairs_count].face1 = f2;
                    ordered_pairs[ordered_pairs_count].face2 = f1;
                    ordered_pairs_count++;
                }
            }

        skipT7: ;
        
        }
            } while (swapped);
    


    
    if (ordered_pairs) {
        free(ordered_pairs);
    }    
}



\n\n

Fixed32 sin_fixed(Fixed32 angle) {
    while (angle > FIXED_PI) angle = FIXED_SUB(angle, FIXED_2PI);
    while (angle < -FIXED_PI) angle = FIXED_ADD(angle, FIXED_2PI);
    
    Fixed32 x = angle;
    Fixed32 x2 = FIXED_MUL_64(x, x);       
    Fixed32 x3 = FIXED_MUL_64(x2, x);      
    Fixed32 x5 = FIXED_MUL_64(x3, x2);     
    Fixed32 x7 = FIXED_MUL_64(x5, x2);     
    
    Fixed32 result = x;
    result = FIXED_SUB(result, FIXED_DIV_64(x3, INT_TO_FIXED(6))); 
    result = FIXED_ADD(result, FIXED_DIV_64(x5, INT_TO_FIXED(120))); 
    result = FIXED_SUB(result, FIXED_DIV_64(x7, INT_TO_FIXED(5040))); 
    
    return result;
}


Fixed32 cos_fixed(Fixed32 angle) {
    return sin_fixed(FIXED_ADD(angle, FIXED_PI_2));
}
\n\n

Model3D* createModel3D(void) {
    
    Model3D* model = (Model3D*)malloc(sizeof(Model3D));
    if (model == NULL) {
        return NULL;
    }
    int n = MAX_VERTICES;
    model->vertices.vertex_count = n;
    
    
    
    model->vertices.x = (Fixed32*)malloc(n * sizeof(Fixed32));
    model->vertices.y = (Fixed32*)malloc(n * sizeof(Fixed32));
    model->vertices.z = (Fixed32*)malloc(n * sizeof(Fixed32));
    model->vertices.xo = (Fixed32*)malloc(n * sizeof(Fixed32));
    model->vertices.yo = (Fixed32*)malloc(n * sizeof(Fixed32));
    model->vertices.zo = (Fixed32*)malloc(n * sizeof(Fixed32));
    model->vertices.x2d = (int*)malloc(n * sizeof(int));
    model->vertices.y2d = (int*)malloc(n * sizeof(int));
    
    if (!model->vertices.x || !model->vertices.y || !model->vertices.z ||
        !model->vertices.xo || !model->vertices.yo || !model->vertices.zo ||
        !model->vertices.x2d || !model->vertices.y2d) {
        printf("Error: Unable to allocate memory for vertex arrays\n");
        keypress();
        
        if (model->vertices.x) free(model->vertices.x);
        if (model->vertices.y) free(model->vertices.y);
        if (model->vertices.z) free(model->vertices.z);
        if (model->vertices.xo) free(model->vertices.xo);
        if (model->vertices.yo) free(model->vertices.yo);
        if (model->vertices.zo) free(model->vertices.zo);
        if (model->vertices.x2d) free(model->vertices.x2d);
        if (model->vertices.y2d) free(model->vertices.y2d);
        free(model);
        return NULL;
    }
    
    
    model->vertices.xHandle = NULL;
    model->vertices.yHandle = NULL;
    model->vertices.zHandle = NULL;
    model->vertices.xoHandle = NULL;
    model->vertices.yoHandle = NULL;
    model->vertices.zoHandle = NULL;
    model->vertices.x2dHandle = NULL;
    model->vertices.y2dHandle = NULL;
    
    
    
    int nf = MAX_FACES;
    
    
    model->faces.vertex_count = (int*)malloc(nf * sizeof(int));
    if (!model->faces.vertex_count) {
        printf("Error: Unable to allocate memory for face vertex_count array\n");
        keypress();
        free(model->vertices.x);
        free(model->vertices.y);
        free(model->vertices.z);
        free(model->vertices.xo);
        free(model->vertices.yo);
        free(model->vertices.zo);
        free(model->vertices.x2d);
        free(model->vertices.y2d);
        free(model);
        return NULL;
    }
    
    
    
    
    int estimated_total_indices = nf * 5;
    model->faces.vertex_indices_buffer = (int*)malloc(estimated_total_indices * sizeof(int));
    if (!model->faces.vertex_indices_buffer) {
        printf("Error: Unable to allocate memory for vertex_indices_buffer\n");
        keypress();
        free(model->vertices.x);
        free(model->vertices.y);
        free(model->vertices.z);
        free(model->vertices.xo);
        free(model->vertices.yo);
        free(model->vertices.zo);
        free(model->vertices.x2d);
        free(model->vertices.y2d);
        free(model->faces.vertex_count);
        free(model);
        return NULL;
    }
    
    
    model->faces.vertex_indices_ptr = (int*)malloc(nf * sizeof(int));
    if (!model->faces.vertex_indices_ptr) {
        printf("Error: Unable to allocate memory for vertex_indices_ptr array\n");
        keypress();
        free(model->vertices.x);
        free(model->vertices.y);
        free(model->vertices.z);
        free(model->vertices.xo);
        free(model->vertices.yo);
        free(model->vertices.zo);
        free(model->vertices.x2d);
        free(model->vertices.y2d);
        free(model->faces.vertex_count);
        free(model->faces.vertex_indices_buffer);
        free(model);
        return NULL;
    }
    
    
    model->faces.z_min = (Fixed32*)malloc(nf * sizeof(Fixed32));
    model->faces.z_max = (Fixed32*)malloc(nf * sizeof(Fixed32));
    if (!model->faces.z_min || !model->faces.z_max) {
        printf("Error: Unable to allocate memory for face depth arrays\n");
        keypress();
        if (model->faces.z_min) free(model->faces.z_min);
        if (model->faces.z_max) free(model->faces.z_max);
        free(model->vertices.x);
        free(model->vertices.y);
        free(model->vertices.z);
        free(model->vertices.xo);
        free(model->vertices.yo);
        free(model->vertices.zo);
        free(model->vertices.x2d);
        free(model->vertices.y2d);
        free(model->faces.vertex_count);
        free(model->faces.vertex_indices_buffer);
        free(model->faces.vertex_indices_ptr);
        free(model);
        return NULL;
    }
    
    model->faces.z_mean = (Fixed32*)malloc(nf * sizeof(Fixed32));
    if (!model->faces.z_mean) {
        printf("Error: Unable to allocate memory for face z_mean array\n");
        keypress();
        if (model->faces.z_mean) free(model->faces.z_mean);
        free(model->vertices.x);
        free(model->vertices.y);
        free(model->vertices.z);
        free(model->vertices.xo);
        free(model->vertices.yo);
        free(model->vertices.zo);
        free(model->vertices.x2d);
        free(model->vertices.y2d);
        free(model->faces.vertex_count);
        free(model->faces.vertex_indices_buffer);
        free(model->faces.vertex_indices_ptr);
        if (model->faces.z_min) free(model->faces.z_min);
        if (model->faces.z_max) free(model->faces.z_max);
        free(model);
        return NULL;
    }

    
    model->faces.plane_a = (Fixed32*)malloc(nf * sizeof(Fixed32));
    model->faces.plane_b = (Fixed32*)malloc(nf * sizeof(Fixed32));
    model->faces.plane_c = (Fixed32*)malloc(nf * sizeof(Fixed32));
    model->faces.plane_d = (Fixed32*)malloc(nf * sizeof(Fixed32));
    if (!model->faces.plane_a || !model->faces.plane_b || !model->faces.plane_c || !model->faces.plane_d) {
        printf("Error: Unable to allocate memory for face plane arrays\n");
        keypress();
        if (model->faces.plane_a) free(model->faces.plane_a);
        if (model->faces.plane_b) free(model->faces.plane_b);
        if (model->faces.plane_c) free(model->faces.plane_c);
        if (model->faces.plane_d) free(model->faces.plane_d);
        if (model->faces.z_mean) free(model->faces.z_mean);
        if (model->faces.z_min) free(model->faces.z_min);
        if (model->faces.z_max) free(model->faces.z_max);
        free(model->vertices.x);
        free(model->vertices.y);
        free(model->vertices.z);
        free(model->vertices.xo);
        free(model->vertices.yo);
        free(model->vertices.zo);
        free(model->vertices.x2d);
        free(model->vertices.y2d);
        free(model->faces.vertex_count);
        free(model->faces.vertex_indices_buffer);
        free(model->faces.vertex_indices_ptr);
        free(model->faces.z_max);
        free(model);
        return NULL;
    }

    
    model->faces.minx = (int*)malloc(nf * sizeof(int));
    model->faces.maxx = (int*)malloc(nf * sizeof(int));
    model->faces.miny = (int*)malloc(nf * sizeof(int));
    model->faces.maxy = (int*)malloc(nf * sizeof(int));
    if (!model->faces.minx || !model->faces.maxx || !model->faces.miny || !model->faces.maxy) {
        printf("Error: Unable to allocate memory for face bounding box arrays\n");
        keypress();
        if (model->faces.minx) free(model->faces.minx);
        if (model->faces.maxx) free(model->faces.maxx);
        if (model->faces.miny) free(model->faces.miny);
        if (model->faces.maxy) free(model->faces.maxy);
        if (model->faces.plane_a) free(model->faces.plane_a);
        if (model->faces.plane_b) free(model->faces.plane_b);
        if (model->faces.plane_c) free(model->faces.plane_c);
        if (model->faces.plane_d) free(model->faces.plane_d);
        if (model->faces.z_mean) free(model->faces.z_mean);
        if (model->faces.z_min) free(model->faces.z_min);
        if (model->faces.z_max) free(model->faces.z_max);
        free(model->vertices.x);
        free(model->vertices.y);
        free(model->vertices.z);
        free(model->vertices.xo);
        free(model->vertices.yo);
        free(model->vertices.zo);
        free(model->vertices.x2d);
        free(model->vertices.y2d);
        free(model->faces.vertex_count);
        free(model->faces.vertex_indices_buffer);
        free(model->faces.vertex_indices_ptr);
        free(model->faces.z_max);
        free(model);
        return NULL;
    }
    
    
    model->faces.display_flag = (int*)malloc(nf * sizeof(int));
    if (!model->faces.display_flag) {
        printf("Error: Unable to allocate memory for face display_flag array\n");
        keypress();
        free(model->vertices.x);
        free(model->vertices.y);
        free(model->vertices.z);
        free(model->vertices.xo);
        free(model->vertices.yo);
        free(model->vertices.zo);
        free(model->vertices.x2d);
        free(model->vertices.y2d);
        free(model->faces.vertex_count);
        free(model->faces.vertex_indices_buffer);
        free(model->faces.vertex_indices_ptr);
        free(model->faces.z_max);
        if (model->faces.z_mean) free(model->faces.z_mean);
        free(model);
        return NULL;
    }
    
    
    model->faces.vertex_countHandle = NULL;
    model->faces.vertex_indicesBufferHandle = NULL;
    model->faces.vertex_indicesPtrHandle = NULL;
    model->faces.z_maxHandle = NULL;
    model->faces.display_flagHandle = NULL;
    model->faces.sorted_face_indicesHandle = NULL;
    model->faces.total_indices = 0;
    
    
    model->faces.sorted_face_indices = (int*)malloc(nf * sizeof(int));
    if (!model->faces.sorted_face_indices) {
        printf("Error: Unable to allocate memory for sorted_face_indices array\n");
        keypress();
        free(model->vertices.x);
        free(model->vertices.y);
        free(model->vertices.z);
        free(model->vertices.xo);
        free(model->vertices.yo);
        free(model->vertices.zo);
        free(model->vertices.x2d);
        free(model->vertices.y2d);
        free(model->faces.vertex_count);
        free(model->faces.vertex_indices_buffer);
        free(model->faces.vertex_indices_ptr);
        if (model->faces.z_min) free(model->faces.z_min);
        if (model->faces.z_max) free(model->faces.z_max);
        if (model->faces.z_mean) free(model->faces.z_mean);
        free(model->faces.display_flag);
        free(model);
        return NULL;
    }
    
    
    model->faces.vertex_countHandle = NULL;
    model->faces.vertex_indicesBufferHandle = NULL;
    model->faces.vertex_indicesPtrHandle = NULL;
    model->faces.z_maxHandle = NULL;
    model->faces.display_flagHandle = NULL;
    model->faces.sorted_face_indicesHandle = NULL;
    model->faces.total_indices = 0;
    
    return model;
}


void destroyModel3D(Model3D* model) {
    if (model != NULL) {
        
        if (model->vertices.x) free(model->vertices.x);
        if (model->vertices.y) free(model->vertices.y);
        if (model->vertices.z) free(model->vertices.z);
        if (model->vertices.xo) free(model->vertices.xo);
        if (model->vertices.yo) free(model->vertices.yo);
        if (model->vertices.zo) free(model->vertices.zo);
        if (model->vertices.x2d) free(model->vertices.x2d);
        if (model->vertices.y2d) free(model->vertices.y2d);
        
        
        if (model->faces.vertex_count) free(model->faces.vertex_count);
        if (model->faces.vertex_indices_buffer) free(model->faces.vertex_indices_buffer);
        if (model->faces.vertex_indices_ptr) free(model->faces.vertex_indices_ptr);
        if (model->faces.z_max) free(model->faces.z_max);
        if (model->faces.z_mean) free(model->faces.z_mean);
        if (model->faces.z_min) free(model->faces.z_min);
        if (model->faces.z_max) free(model->faces.z_max);
        if (model->faces.plane_a) free(model->faces.plane_a);
        if (model->faces.plane_b) free(model->faces.plane_b);
        if (model->faces.plane_c) free(model->faces.plane_c);
        if (model->faces.plane_d) free(model->faces.plane_d);
        if (model->faces.minx) free(model->faces.minx);
        if (model->faces.maxx) free(model->faces.maxx);
        if (model->faces.miny) free(model->faces.miny);
        if (model->faces.maxy) free(model->faces.maxy);
        if (model->faces.display_flag) free(model->faces.display_flag);
        if (model->faces.sorted_face_indices) free(model->faces.sorted_face_indices);
        
        
        free(model);
    }
}


int loadModel3D(Model3D* model, const char* filename) {
    
    if (model == NULL || filename == NULL) {
        return -1;  
    }
    
    
    
    readVertices_last_count = model->vertices.vertex_count;
    
    int vcount = readVertices(filename, &model->vertices, MAX_VERTICES);
    if (vcount < 0) {
        return -1;  
    }
    model->vertices.vertex_count = vcount;
    
    
    
    int fcount = readFaces_model(filename, model);
    if (fcount < 0) {
        
        printf("\nWarning: Unable to read faces\n");
        model->faces.face_count = 0;  
    } else {
        model->faces.face_count = fcount;
    }
    
    return 0;  
}
\n\n

void getObserverParams(ObserverParams* params) {
    char input[50];  
    
    
    printf("\nObserver parameters:\n");
    printf("============================\n");
    printf("(Press ENTER to use default values)\n");
    printf("(Enter 'debug' to see values used)\n");
    
    
    printf("Horizontal angle (degrees, default 30): ");
    if (fgets(input, sizeof(input), stdin) != NULL) {
        
        input[strcspn(input, "\n")] = 0;
        if (strlen(input) == 0) {
            params->angle_h = 30;     
        } else {
            params->angle_h = atoi(input);  
        }
    } else {
        params->angle_h = 30;         
    }
    
    
    printf("Vertical angle (degrees, default 20): ");
    if (fgets(input, sizeof(input), stdin) != NULL) {
        
        input[strcspn(input, "\n")] = 0;
        if (strlen(input) == 0) {
            params->angle_v = 20;     
        } else {
            params->angle_v = atoi(input);  
        }
    } else {
        params->angle_v = 20;         
    }
    

    
    printf("Screen rotation angle (degrees, default 0): ");
    if (fgets(input, sizeof(input), stdin) != NULL) {
        
        input[strcspn(input, "\n")] = 0;
        if (strlen(input) == 0) {
            params->angle_w = 0;      
        } else {
            params->angle_w = atoi(input);  
        }
    } else {
        params->angle_w = 0;          
    }

    
    printf("Distance (default 30): ");
    if (fgets(input, sizeof(input), stdin) != NULL) {
        
        input[strcspn(input, "\n")] = 0;
        if (strlen(input) == 0) {
            params->distance = FLOAT_TO_FIXED(30.0);    
        } else {
            params->distance = FLOAT_TO_FIXED(atof(input)); 
        }
    } else {
        params->distance = FLOAT_TO_FIXED(30.0);        
    }

    
    printf("Observer angles (degrees) - H: %d, V: %d, W: %d\n", params->angle_h, params->angle_v, params->angle_w);
}



void processModelFast(Model3D* model, ObserverParams* params, const char* filename) {
    int i;
    Fixed32 rad_h, rad_v, rad_w;
    Fixed32 cos_h, sin_h, cos_v, sin_v, cos_w, sin_w;
    Fixed32 x, y, z, zo, xo, yo;
    Fixed32 inv_zo, x2d_temp, y2d_temp;
    
    
    cos_h = cos_deg_int(params->angle_h);
    sin_h = sin_deg_int(params->angle_h);
    cos_v = cos_deg_int(params->angle_v);
    sin_v = sin_deg_int(params->angle_v);
    cos_w = cos_deg_int(params->angle_w);
    sin_w = sin_deg_int(params->angle_w);

    
    const Fixed32 cos_h_cos_v = FIXED_MUL_64(cos_h, cos_v);
    const Fixed32 sin_h_cos_v = FIXED_MUL_64(sin_h, cos_v);
    const Fixed32 cos_h_sin_v = FIXED_MUL_64(cos_h, sin_v);
    const Fixed32 sin_h_sin_v = FIXED_MUL_64(sin_h, sin_v);
    const Fixed32 scale = FLOAT_TO_FIXED(100.0);
    const Fixed32 centre_x_f = FLOAT_TO_FIXED((float)CENTRE_X);
    const Fixed32 centre_y_f = FLOAT_TO_FIXED((float)CENTRE_Y);
    const Fixed32 distance = params->distance;
    
    
    
    
    VertexArrays3D* vtx = &model->vertices;
    
    for (i = 0; i < vtx->vertex_count; i++) {
        x = vtx->x[i];
        y = vtx->y[i];
        z = vtx->z[i];
        
        Fixed32 term1 = FIXED_MUL_64(x, cos_h_cos_v);
        Fixed32 term2 = FIXED_MUL_64(y, sin_h_cos_v);
        Fixed32 term3 = FIXED_MUL_64(z, sin_v);
        zo = FIXED_ADD(FIXED_SUB(FIXED_SUB(FIXED_NEG(term1), term2), term3), distance);
        if (zo > 0) {
            xo = FIXED_ADD(FIXED_NEG(FIXED_MUL_64(x, sin_h)), FIXED_MUL_64(y, cos_h));
            yo = FIXED_ADD(FIXED_SUB(FIXED_NEG(FIXED_MUL_64(x, cos_h_sin_v)), FIXED_MUL_64(y, sin_h_sin_v)), FIXED_MUL_64(z, cos_v));
            vtx->zo[i] = zo;
            vtx->xo[i] = xo;
            vtx->yo[i] = yo;
            inv_zo = FIXED_DIV_64(scale, zo);
            x2d_temp = FIXED_ADD(FIXED_MUL_64(xo, inv_zo), centre_x_f);
            y2d_temp = FIXED_SUB(centre_y_f, FIXED_MUL_64(yo, inv_zo));
            vtx->x2d[i] = FIXED_ROUND_TO_INT(FIXED_ADD(FIXED_SUB(FIXED_MUL_64(cos_w, FIXED_SUB(x2d_temp, centre_x_f)), FIXED_MUL_64(sin_w, FIXED_SUB(centre_y_f, y2d_temp))), centre_x_f));
            vtx->y2d[i] = FIXED_ROUND_TO_INT(FIXED_SUB(centre_y_f, FIXED_ADD(FIXED_MUL_64(sin_w, FIXED_SUB(x2d_temp, centre_x_f)), FIXED_MUL_64(cos_w, FIXED_SUB(centre_y_f, y2d_temp)))));
        } else {
            vtx->zo[i] = zo;
            vtx->xo[i] = 0;
            vtx->yo[i] = 0;
            vtx->x2d[i] = -1;
            vtx->y2d[i] = -1;
        }
    }
    

    
    
    long t_start, t_end;

    t_start = GetTick();
    calculateFaceDepths(model, NULL, model->faces.face_count);
    t_end = GetTick();
    {
        long elapsed = t_end - t_start;
        double ms = ((double)elapsed * 1000.0) / 60.0; 
        printf("[TIMING] calculateFaceDepths: %ld ticks (%.2f ms)\n", elapsed, ms);
    }

    
    
    for (i = 0; i < model->faces.face_count; i++) {
        model->faces.sorted_face_indices[i] = i;
    }

    
    t_start = GetTick();
    painter_newell_sancha(model, model->faces.face_count);
    t_end = GetTick();

    if (!PERFORMANCE_MODE)
    {
        long elapsed = t_end - t_start;
        double ms = ((double)elapsed * 1000.0) / 60.0; 
        printf("[TIMING] painter_newell_sancha: %ld ticks (%.2f ms)\n", elapsed, ms);
        keypress();
    }
}
\n\n

int readVertices(const char* filename, VertexArrays3D* vtx, int max_vertices) {
    FILE *file;
    char line[MAX_LINE_LENGTH];
    int line_number = 1;
    int vertex_count = 0;
    
    
    file = fopen(filename, "r");
    if (file == NULL) {
        printf("[DEBUG] readVertices: fopen failed\n");
        printf("Error: Unable to open file '%s'\n", filename);
        printf("Check that the file exists and you have read permissions.\n");
        return -1;
    }
    
    printf("\nReading vertices from file...'%s':\n", filename);
    
    
    while (fgets(line, sizeof(line), file) != NULL) {
        if (line[0] == 'v' && line[1] == ' ') {
            if (vertex_count < max_vertices) {
                float x, y, z;
                if (sscanf(line + 2, "%f %f %f", &x, &y, &z) == 3) {
                    vtx->x[vertex_count] = FLOAT_TO_FIXED(x);
                    vtx->y[vertex_count] = FLOAT_TO_FIXED(y);
                    vtx->z[vertex_count] = FLOAT_TO_FIXED(z);
                    vertex_count++;
                    if (vertex_count % 10 == 0) printf("..");

                } else {
                    printf("[\nDEBUG] readVertices: sscanf failed at line %d: %s\n", line_number, line);
                    keypress();
                }
            } else {
                printf("\n[DEBUG] readVertices: vertex limit reached (%d)\n", max_vertices);
                keypress();
            }
        }
        line_number++;
    }
    printf("\n");
    printf("Reading vertices finished : %d vertices read.\n", vertex_count);

    
    fclose(file);
    
    return vertex_count;
}

int readFaces_model(const char* filename, Model3D* model) {
    FILE *file;
    char line[MAX_LINE_LENGTH];
    int line_number = 1;
    int face_count = 0;
    int i;
    
    if (model == NULL || model->faces.vertex_count == NULL) {
        printf("Error: Invalid model structure for readFaces_model\n");
        return -1;
    }
    
    
    file = fopen(filename, "r");
    if (file == NULL) {
        printf("Error: Unable to open file '%s' to read faces\n", filename);
        return -1;
    }
    
    printf("\nReading faces from file '%s' :\n", filename);
    
    int buffer_pos = 0;
    
    
    while (fgets(line, sizeof(line), file) != NULL) {
        if (line[0] == 'f' && line[1] == ' ') {
            if (face_count < MAX_FACES) {
                model->faces.vertex_count[face_count] = 0;
                model->faces.display_flag[face_count] = 1;
                model->faces.vertex_indices_ptr[face_count] = buffer_pos;
                
                char *ptr = line + 2;
                int temp_indices[MAX_FACE_VERTICES];
                int temp_vertex_count = 0;
                int invalid_index_found = 0;
                
                
                while (*ptr != '\0' && *ptr != '\n' && temp_vertex_count < MAX_FACE_VERTICES) {
                    while (*ptr == ' ' || *ptr == '\t') ptr++;
                    
                    if (*ptr == '\0' || *ptr == '\n') break;
                    
                    int vertex_index = 0;
                    while (*ptr >= '0' && *ptr <= '9') {
                        vertex_index = vertex_index * 10 + (*ptr - '0');
                        ptr++;
                    }
                    
                    while (*ptr != '\0' && *ptr != ' ' && *ptr != '\t' && *ptr != '\n') {
                        ptr++;
                    }
                    
                    if (vertex_index >= 1) {
                        if (vertex_index > readVertices_last_count) {
                            invalid_index_found = 1;
                        }
                        temp_indices[temp_vertex_count] = vertex_index;
                        temp_vertex_count++;
                    }
                }
                
                if (invalid_index_found) {
                    printf("\nERROR: Face at line %d references vertex index > %d vertices\n", 
                           line_number, readVertices_last_count);
                    fclose(file);
                    return -1;
                } else {
                    for (i = 0; i < temp_vertex_count; i++) {
                        model->faces.vertex_indices_buffer[buffer_pos++] = temp_indices[i];
                    }
                    model->faces.vertex_count[face_count] = temp_vertex_count;
                    model->faces.total_indices += temp_vertex_count;
                    
                    if (model->faces.vertex_count[face_count] > 0) {
                        face_count++;
                        if (face_count % 10 == 0) {printf(".");}
                    } else {
                        printf("     -> WARNING: Face without valid vertices ignored\n");
                    }
                }
            } else {
                printf("     -> WARNING: Face limit reached (%d)\n", MAX_FACES);
            }
        }
        
        line_number++;
    }
    
    
    fclose(file);
    
    model->faces.face_count = face_count;
    
    for (i = 0; i < face_count; i++) {
        model->faces.sorted_face_indices[i] = i;
    }
    
    printf("\nReading faces finished : %d faces read.\n", face_count);
    return face_count;
}

void transformToObserver(VertexArrays3D* vtx, int angle_h_deg, int angle_v_deg, Fixed32 distance) {
    int i;
    Fixed32 cos_h, sin_h, cos_v, sin_v;
    Fixed32 x, y, z;
    cos_h = cos_deg_int(angle_h_deg);
    sin_h = sin_deg_int(angle_h_deg);
    cos_v = cos_deg_int(angle_v_deg);
    sin_v = sin_deg_int(angle_v_deg);
    Fixed32 cos_h_cos_v = FIXED_MUL_64(cos_h, cos_v);
    Fixed32 sin_h_cos_v = FIXED_MUL_64(sin_h, cos_v);
    Fixed32 cos_h_sin_v = FIXED_MUL_64(cos_h, sin_v);
    Fixed32 sin_h_sin_v = FIXED_MUL_64(sin_h, sin_v);

    for (i = 0; i < vtx->vertex_count; i++) {
        x = vtx->x[i];
        z = vtx->z[i];
        vtx->xo[i] = FIXED_ADD(
            FIXED_MUL_64(x, cos_h_cos_v),
            FIXED_MUL_64(y, sin_h_cos_v)
        );
        vtx->yo[i] = FIXED_ADD(
            FIXED_SUB(
                FIXED_MUL_64(-x, cos_h_sin_v),
                FIXED_MUL_64(y, sin_h_sin_v)
            ),
            FIXED_MUL_64(z, cos_v)
        );
        vtx->zo[i] = FIXED_ADD(
            FIXED_ADD(
                FIXED_MUL_64(-x, sin_h),
                FIXED_MUL_64(-y, cos_h)
            ),
            distance
        );
    }
}

void projectTo2D(VertexArrays3D* vtx, int angle_w_deg) {
    int i;
    Fixed32 cos_w, sin_w;
    Fixed32 x2d_temp, y2d_temp;
    cos_w = cos_deg_int(angle_w_deg);
    sin_w = sin_deg_int(angle_w_deg);
    const Fixed32 scale = INT_TO_FIXED(100);
    const Fixed32 centre_x_f = INT_TO_FIXED(CENTRE_X);
    const Fixed32 centre_y_f = INT_TO_FIXED(CENTRE_Y);

    for (i = 0; i < vtx->vertex_count; i++) {
        if (vtx->zo[i] > 0) {
            Fixed32 xo = vtx->xo[i];
            Fixed32 yo = vtx->yo[i];
            Fixed32 inv_zo = FIXED_DIV_64(scale, vtx->zo[i]);
            x2d_temp = FIXED_ADD(FIXED_MUL_64(xo, inv_zo), centre_x_f);
            y2d_temp = FIXED_SUB(centre_y_f, FIXED_MUL_64(yo, inv_zo));
            vtx->x2d[i] = FIXED_ROUND_TO_INT(FIXED_ADD(FIXED_SUB(FIXED_MUL_64(cos_w, FIXED_SUB(x2d_temp, centre_x_f)), FIXED_MUL_64(sin_w, FIXED_SUB(centre_y_f, y2d_temp))), centre_x_f));
            vtx->y2d[i] = FIXED_ROUND_TO_INT(FIXED_SUB(centre_y_f, FIXED_ADD(FIXED_MUL_64(sin_w, FIXED_SUB(x2d_temp, centre_x_f)), FIXED_MUL_64(cos_w, FIXED_SUB(centre_y_f, y2d_temp)))));
        } else {
            vtx->x2d[i] = -1;
            vtx->y2d[i] = -1;
        }
    }
}


void calculateFaceDepths(Model3D* model, Face3D* faces, int face_count) {
    int i, j;
    VertexArrays3D* vtx = &model->vertices;
    FaceArrays3D* face_arrays = &model->faces;
    
    for (i = 0; i < face_count; i++) {
        Fixed32 z_min = FLOAT_TO_FIXED(9999.0);
        Fixed32 z_max = FLOAT_TO_FIXED(-9999.0);
        int display_flag = 1;
        Fixed32 sum = 0;
        int n = face_arrays->vertex_count[i];
        int minx = 9999, maxx = -9999, miny = 9999, maxy = -9999;
        
        int offset = face_arrays->vertex_indices_ptr[i];
        for (j = 0; j < n; j++) {
            int vertex_idx = face_arrays->vertex_indices_buffer[offset + j] - 1;
            if (vertex_idx >= 0) {
                Fixed32 zo = vtx->zo[vertex_idx];
                if (zo <= 0) display_flag = 0;
                if (zo < z_min) z_min = zo;
                if (zo > z_max) z_max = zo;
                sum += zo;
                int x2d = vtx->x2d[vertex_idx];
                int y2d = vtx->y2d[vertex_idx];
                if (x2d < minx) minx = x2d;
                if (x2d > maxx) maxx = x2d;
                if (y2d < miny) miny = y2d;
                if (y2d > maxy) maxy = y2d;
            }
        }
        Fixed32 a = 0, b = 0, c = 0, d = 0;
        if (n > 0) {
            for (j = 0; j < n; j++) {
                int idx1 = face_arrays->vertex_indices_buffer[offset + j] - 1;
                int idx2 = face_arrays->vertex_indices_buffer[offset + ((j+1)%n)] - 1;
                if (idx1 >= 0 && idx2 >= 0) {
                    Fixed32 x1 = vtx->xo[idx1], y1 = vtx->yo[idx1], z1 = vtx->zo[idx1];
                    Fixed32 x2 = vtx->xo[idx2], y2 = vtx->yo[idx2], z2 = vtx->zo[idx2];
                    a += (y1 - y2) * (z1 + z2);
                    b += (z1 - z2) * (x1 + x2);
                    c += (x1 - x2) * (y1 + y2);
                }
            }
            Fixed32 len_sq = a*a + b*b + c*c;
            Fixed32 min_length_sq = FLOAT_TO_FIXED(0.01);
            if (len_sq < min_length_sq) {
                face_arrays->plane_a[i] = 0;
                face_arrays->plane_b[i] = 0;
                face_arrays->plane_c[i] = 0;
                face_arrays->plane_d[i] = 0;
            } else {
                Fixed32 len = FLOAT_TO_FIXED(sqrt(FIXED_TO_FLOAT(len_sq)));
                a = FIXED_DIV(a, len);
                b = FIXED_DIV(b, len);
                c = FIXED_DIV(c, len);
                int v0 = face_arrays->vertex_indices_buffer[offset] - 1;
                if (v0 >= 0) {
                    d = FIXED_NEG(FIXED_ADD(FIXED_ADD(FIXED_MUL_64(a, vtx->xo[v0]), FIXED_MUL_64(b, vtx->yo[v0])), FIXED_MUL_64(c, vtx->zo[v0])));
                } else d = 0;
                face_arrays->plane_a[i] = a;
                face_arrays->plane_b[i] = b;
                face_arrays->plane_c[i] = c;
                face_arrays->plane_d[i] = d;
            }
        } else {
            face_arrays->plane_a[i] = 0;
            face_arrays->plane_b[i] = 0;
            face_arrays->plane_c[i] = 0;
            face_arrays->plane_d[i] = 0;
        }

        face_arrays->z_min[i] = z_min;
        face_arrays->z_max[i] = z_max;
        face_arrays->display_flag[i] = display_flag;
        if (n > 0) {
            face_arrays->z_mean[i] = sum / n;
            face_arrays->minx[i] = minx;
            face_arrays->maxx[i] = maxx;
            face_arrays->miny[i] = miny;
            face_arrays->maxy[i] = maxy;
        } else {
            face_arrays->z_mean[i] = 0;
            face_arrays->z_min[i] = 0;
            face_arrays->z_max[i] = 0;
            face_arrays->minx[i] = 0;
            face_arrays->maxx[i] = 0;
            face_arrays->miny[i] = 0;
            face_arrays->maxy[i] = 0;
        }
    }
}


#define SWAP_FACE(faces, i, j) \
    do { \
        int temp_idx = faces->sorted_face_indices[i]; \
        faces->sorted_face_indices[i] = faces->sorted_face_indices[j]; \
        faces->sorted_face_indices[j] = temp_idx; \
    } while (0)



void drawPolygons(Model3D* model, int* vertex_count, int face_count, int vertex_count_total) {
    int i, j;
    VertexArrays3D* vtx = &model->vertices;
    FaceArrays3D* faces = &model->faces;
    Handle polyHandle;
    DynamicPolygon *poly;
    int min_x, max_x, min_y, max_y;
    int valid_faces_drawn = 0;
    int invalid_faces_skipped = 0;
    int triangle_count = 0;
    int quad_count = 0;
    Pattern pat;
    
    if (globalPolyHandle == NULL) {
        int max_polySize = 2 + 8 + (4 * 4);
        globalPolyHandle = NewHandle((long)max_polySize, userid(), 0xC014, 0L);
        if (globalPolyHandle == NULL) {
            printf("Error: Unable to allocate global polygon handle\n");
            return;
        }
    }
    
    polyHandle = globalPolyHandle;
    
    if (poly_handle_locked) {
        HUnlock(polyHandle);
        poly_handle_locked = 0;
    }
    HLock(polyHandle);
    poly_handle_locked = 1;

    SetPenMode(0);

    
    int start_face = 0;
    int max_faces_to_draw = face_count;
    for (i = start_face; i < start_face + max_faces_to_draw; i++) {
        int face_id = faces->sorted_face_indices[i];
        if (faces->display_flag[face_id] == 0) continue;
        if (faces->vertex_count[face_id] >= 3) {
            int offset = faces->vertex_indices_ptr[face_id];

            
            int polySize = 2 + 8 + (faces->vertex_count[face_id] * 4);
            poly = (DynamicPolygon *)*polyHandle;
            poly->polySize = polySize;
            min_x = max_x = min_y = max_y = -1;
            for (j = 0; j < faces->vertex_count[face_id]; j++) {
                int vertex_idx = faces->vertex_indices_buffer[offset + j] - 1;
                
                if (vertex_idx >= 0 && vertex_idx < vtx->vertex_count) {
                    poly->polyPoints[j].h = mode / 320 * vtx->x2d[vertex_idx];
                    poly->polyPoints[j].v = vtx->y2d[vertex_idx];
                    if (min_x == -1 || vtx->x2d[vertex_idx] < min_x) min_x = vtx->x2d[vertex_idx];
                    if (max_x == -1 || vtx->x2d[vertex_idx] > max_x) max_x = vtx->x2d[vertex_idx];
                    if (min_y == -1 || vtx->y2d[vertex_idx] < min_y) min_y = vtx->y2d[vertex_idx];
                    if (max_y == -1 || vtx->y2d[vertex_idx] > max_y) max_y = vtx->y2d[vertex_idx];
                }
            }
            poly->polyBBox.h1 = min_x;
            poly->polyBBox.v1 = min_y;
            poly->polyBBox.h2 = max_x;
            poly->polyBBox.v2 = max_y;
            SetSolidPenPat(14);
            GetPenPat(pat);
            FillPoly(polyHandle, pat);
            SetSolidPenPat(7);
            FramePoly(polyHandle);
            valid_faces_drawn++;
            if (faces->vertex_count[face_id] == 3) triangle_count++;
            else if (faces->vertex_count[face_id] == 4) quad_count++;
        } else {
            invalid_faces_skipped++;
        }
    }
    \n\n}

void DoColor() {
        Rect r;
        unsigned char pstr[4];  

        SetRect (&r, 0, 1, mode / 320 *10, 11);
        for (int i = 0; i < 16; i++) {
            SetSolidPenPat(i);
            PaintRect(&r);

            if (i == 0) {
                SetSolidPenPat(15); 
                FrameRect(&r);
            }

            MoveTo(r.h1, r.v2+10);
            
            if (i < 10) {
                pstr[0] = 1;           
                pstr[1] = '0' + i;     
            } else {
                pstr[0] = 2;           
                pstr[1] = '0' + (i / 10);      
                pstr[2] = '0' + (i % 10);      
            }
            DrawString(pstr);
            OffsetRect(&r, 20, 0);
        }
}

void DoText() {
        shroff();
        putchar((char) 12); 
}
    int main() {
        Model3D* model;
        ObserverParams params;
        char filename[100];
        char input[50];
        int colorpalette = 0; 

    newmodel:
        printf("===================================\n");
        printf("       3D OBJ file viewer\n");
        printf("===================================\n\n");

        
        model = createModel3D();
        if (model == NULL) {
            printf("Error: Unable to allocate memory for 3D model\n");
            printf("Press any key to quit...\n");
            keypress();
            return 1;
        }

        
        printf("Enter the filename to read: ");
        if (fgets(filename, sizeof(filename), stdin) != NULL) {
            size_t len = strlen(filename);
            if (len > 0 && filename[len-1] == '\n') {
                filename[len-1] = '\0';
            }
        }

        
        if (loadModel3D(model, filename) < 0) {
            printf("\nError loading file\n");
            printf("Press any key to quit...\n");
            keypress();
            destroyModel3D(model);
            return 1;
        }

        
        getObserverParams(&params);

    bigloop:
        
        printf("Processing model...\n");
        processModelFast(model, &params, filename);

    loopReDraw:
        {
            int key = 0;
            char input[50];

            if (model->faces.face_count > 0) {
                
                startgraph(mode);
                
                drawPolygons(model, model->faces.vertex_count, model->faces.face_count, model->vertices.vertex_count);
                
                if (colorpalette == 1) { 
                    DoColor(); 
                }

                
        asm 
            {
            sep #0x20
        loop:
            lda >0xC000     
            bpl loop        
            and #0x007f     
            sta >0xC010     
            sta key         
            rep #0x30
            }

        endgraph();        
        }

        DoText();           

    #if ENABLE_DEBUG_SAVE
        sprintf(input, "You pressed key code: %d\n", key);
        printf("%s", input);
    #endif

        
        switch (key) {
            case 32:  
                printf("===================================\n");
                printf(" Model information and parameters\n");
                printf("===================================\n");
                printf("Model: %s\n", filename);
                printf("Vertices: %d, Faces: %d\n", model->vertices.vertex_count, model->faces.face_count);
                printf("Observer Parameters:\n");
                printf("    Distance: %.2f\n", FIXED_TO_FLOAT(params.distance));
                printf("    Horizontal Angle: %d\n", params.angle_h);
                printf("    Vertical Angle: %d\n", params.angle_v);
                printf("    Screen Rotation Angle: %d\n", params.angle_w);
                printf("===================================\n");
                printf("\n");
                printf("Press any key to continue...\n");
                keypress();
                goto loopReDraw;

            case 65:  
            case 97:  
                params.distance = params.distance - (params.distance / 10);
                goto bigloop;

            case 90:  
            case 122: 
                params.distance = params.distance + (params.distance / 10);
                goto bigloop;

            case 21:  
                params.angle_h = normalize_deg(params.angle_h + 10);
                goto bigloop;

            case 8:   
                params.angle_h = normalize_deg(params.angle_h - 10);
                goto bigloop;

            case 10:  
                params.angle_v = normalize_deg(params.angle_v - 10);
                goto bigloop;

            case 11:  
                params.angle_v = normalize_deg(params.angle_v + 10);
                goto bigloop;

            case 87:  
            case 119: 
                params.angle_w = normalize_deg(params.angle_w + 10);
                goto bigloop;

            case 88:  
            case 120: 
                params.angle_w = normalize_deg(params.angle_w - 10);
                goto bigloop;
        
            case 67:  
            case 99:  
                colorpalette ^= 1; 
                goto loopReDraw;

            case 78:  
            case 110: 
                destroyModel3D(model);
                goto newmodel;
        
            
            case 72:  
            case 104: 
                printf("===================================\n");
                printf("    HELP - Keyboard Controller\n");
                printf("===================================\n\n");
                printf("Space: Display model info\n");
                printf("A/Z: Increase/Decrease distance\n");
                printf("Arrow Left/Right: Decrease/Increase horizontal angle\n");
                printf("Arrow Up/Down: Increase/Decrease vertical angle\n");
                printf("W/X: Increase/Decrease screen rotation angle\n");
                printf("C: Toggle color palette display\n");
                printf("N: Load new model\n");
                printf("H: Display this help message\n");
                printf("ESC: Quit program\n");
                printf("===================================\n");
                printf("\n");
                printf("Press any key to continue...\n");
                keypress();
                goto loopReDraw;

            case 27:  
                goto end;
            
            default:  
                goto loopReDraw;
        }
        }  

        end:
        
        
        if (globalPolyHandle != NULL) {
            if (poly_handle_locked) {
                HUnlock(globalPolyHandle);
            }
            DisposeHandle(globalPolyHandle);
            globalPolyHandle = NULL;
        }
        destroyModel3D(model);
        return 0;
    }