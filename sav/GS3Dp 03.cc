\n\n\n\n#include <stdio.h>\n#include <asm.h>\n#include <string.h>\n#include <misctool.h>\n#include <stdlib.h>\n#include <math.h>\n#include <quickdraw.h>\n#include <event.h>\n#include <memory.h>\n#include <window.h>\n#include <orca.h>\n\nint readVertices_last_count = 0;\n\nstatic Handle globalPolyHandle = NULL;\nstatic int poly_handle_locked = 0;\n\n\n\n\n\ntypedef long Fixed32;           \ntypedef long long Fixed64;      \n\n#define FIXED_SHIFT     16\n#define FIXED_SCALE     (1L << FIXED_SHIFT)\n#define FIXED_MASK      (FIXED_SCALE - 1)\n#define FIXED_HALF      (FIXED_SCALE >> 1)\n\n\n#define FIXED_PI        205887L\n#define FIXED_2PI       411775L\n#define FIXED_PI_2      102944L\n#define FIXED_ONE       FIXED_SCALE\n#define FIXED_PI_180    1143LL\n\n\n\n\nstatic const Fixed32 sin_table[360] = {\n    0, 1144, 2287, 3430, 4572, 5712, 6850, 7987, 9121, 10252,\n    11380, 12505, 13626, 14742, 15855, 16962, 18064, 19161, 20252, 21336,\n    22415, 23486, 24550, 25607, 26656, 27697, 28729, 29753, 30767, 31772,\n    32768, 33754, 34729, 35693, 36647, 37590, 38521, 39441, 40348, 41243,\n    42126, 42995, 43852, 44695, 45525, 46341, 47143, 47930, 48703, 49461,\n    50203, 50931, 51643, 52339, 53020, 53684, 54332, 54963, 55578, 56175,\n    56756, 57319, 57865, 58393, 58903, 59396, 59870, 60326, 60764, 61183,\n    61584, 61966, 62328, 62672, 62997, 63303, 63589, 63856, 64104, 64332,\n    64540, 64729, 64898, 65048, 65177, 65287, 65376, 65446, 65496, 65526,\n    65536, 65526, 65496, 65446, 65376, 65287, 65177, 65048, 64898, 64729,\n    64540, 64332, 64104, 63856, 63589, 63303, 62997, 62672, 62328, 61966,\n    61584, 61183, 60764, 60326, 59870, 59396, 58903, 58393, 57865, 57319,\n    56756, 56175, 55578, 54963, 54332, 53684, 53020, 52339, 51643, 50931,\n    50203, 49461, 48703, 47930, 47143, 46341, 45525, 44695, 43852, 42995,\n    42126, 41243, 40348, 39441, 38521, 37590, 36647, 35693, 34729, 33754,\n    32768, 31772, 30767, 29753, 28729, 27697, 26656, 25607, 24550, 23486,\n    22415, 21336, 20252, 19161, 18064, 16962, 15855, 14742, 13626, 12505,\n    11380, 10252, 9121, 7987, 6850, 5712, 4572, 3430, 2287, 1144,\n    0, -1144, -2287, -3430, -4572, -5712, -6850, -7987, -9121, -10252,\n    -11380, -12505, -13626, -14742, -15855, -16962, -18064, -19161, -20252, -21336,\n    -22415, -23486, -24550, -25607, -26656, -27697, -28729, -29753, -30767, -31772,\n    -32768, -33754, -34729, -35693, -36647, -37590, -38521, -39441, -40348, -41243,\n    -42126, -42995, -43852, -44695, -45525, -46341, -47143, -47930, -48703, -49461,\n    -50203, -50931, -51643, -52339, -53020, -53684, -54332, -54963, -55578, -56175,\n    -56756, -57319, -57865, -58393, -58903, -59396, -59870, -60326, -60764, -61183,\n    -61584, -61966, -62328, -62672, -62997, -63303, -63589, -63856, -64104, -64332,\n    -64540, -64729, -64898, -65048, -65177, -65287, -65376, -65446, -65496, -65526,\n    -65536, -65526, -65496, -65446, -65376, -65287, -65177, -65048, -64898, -64729,\n    -64540, -64332, -64104, -63856, -63589, -63303, -62997, -62672, -62328, -61966,\n    -61584, -61183, -60764, -60326, -59870, -59396, -58903, -58393, -57865, -57319,\n    -56756, -56175, -55578, -54963, -54332, -53684, -53020, -52339, -51643, -50931,\n    -50203, -49461, -48703, -47930, -47143, -46341, -45525, -44695, -43852, -42995,\n    -42126, -41243, -40348, -39441, -38521, -37590, -36647, -35693, -34729, -33754,\n    -32768, -31772, -30767, -29753, -28729, -27697, -26656, -25607, -24550, -23486,\n    -22415, -21336, -20252, -19161, -18064, -16962, -15855, -14742, -13626, -12505,\n    -11380, -10252, -9121, -7987, -6850, -5712, -4572, -3430, -2287, -1144,\n};\nstatic const Fixed32 cos_table[360] = {\n    65536, 65526, 65496, 65446, 65376, 65287, 65177, 65048, 64898, 64729,\n    64540, 64332, 64104, 63856, 63589, 63303, 62997, 62672, 62328, 61966,\n    61584, 61183, 60764, 60326, 59870, 59396, 58903, 58393, 57865, 57319,\n    56756, 56175, 55578, 54963, 54332, 53684, 53020, 52339, 51643, 50931,\n    50203, 49461, 48703, 47930, 47143, 46341, 45525, 44695, 43852, 42995,\n    42126, 41243, 40348, 39441, 38521, 37590, 36647, 35693, 34729, 33754,\n    32768, 31772, 30767, 29753, 28729, 27697, 26656, 25607, 24550, 23486,\n    22415, 21336, 20252, 19161, 18064, 16962, 15855, 14742, 13626, 12505,\n    11380, 10252, 9121, 7987, 6850, 5712, 4572, 3430, 2287, 1144,\n    0, -1144, -2287, -3430, -4572, -5712, -6850, -7987, -9121, -10252,\n    -11380, -12505, -13626, -14742, -15855, -16962, -18064, -19161, -20252, -21336,\n    -22415, -23486, -24550, -25607, -26656, -27697, -28729, -29753, -30767, -31772,\n    -32768, -33754, -34729, -35693, -36647, -37590, -38521, -39441, -40348, -41243,\n    -42126, -42995, -43852, -44695, -45525, -46341, -47143, -47930, -48703, -49461,\n    -50203, -50931, -51643, -52339, -53020, -53684, -54332, -54963, -55578, -56175,\n    -56756, -57319, -57865, -58393, -58903, -59396, -59870, -60326, -60764, -61183,\n    -61584, -61966, -62328, -62672, -62997, -63303, -63589, -63856, -64104, -64332,\n    -64540, -64729, -64898, -65048, -65177, -65287, -65376, -65446, -65496, -65526,\n    -65536, -65526, -65496, -65446, -65376, -65287, -65177, -65048, -64898, -64729,\n    -64540, -64332, -64104, -63856, -63589, -63303, -62997, -62672, -62328, -61966,\n    -61584, -61183, -60764, -60326, -59870, -59396, -58903, -58393, -57865, -57319,\n    -56756, -56175, -55578, -54963, -54332, -53684, -53020, -52339, -51643, -50931,\n    -50203, -49461, -48703, -47930, -47143, -46341, -45525, -44695, -43852, -42995,\n    -42126, -41243, -40348, -39441, -38521, -37590, -36647, -35693, -34729, -33754,\n    -32768, -31772, -30767, -29753, -28729, -27697, -26656, -25607, -24550, -23486,\n    -22415, -21336, -20252, -19161, -18064, -16962, -15855, -14742, -13626, -12505,\n    -11380, -10252, -9121, -7987, -6850, -5712, -4572, -3430, -2287, -1144,\n    0, 1144, 2287, 3430, 4572, 5712, 6850, 7987, 9121, 10252,\n    11380, 12505, 13626, 14742, 15855, 16962, 18064, 19161, 20252, 21336,\n    22415, 23486, 24550, 25607, 26656, 27697, 28729, 29753, 30767, 31772,\n    32768, 33754, 34729, 35693, 36647, 37590, 38521, 39441, 40348, 41243,\n    42126, 42995, 43852, 44695, 45525, 46341, 47143, 47930, 48703, 49461,\n    50203, 50931, 51643, 52339, 53020, 53684, 54332, 54963, 55578, 56175,\n    56756, 57319, 57865, 58393, 58903, 59396, 59870, 60326, 60764, 61183,\n    61584, 61966, 62328, 62672, 62997, 63303, 63589, 63856, 64104, 64332,\n    64540, 64729, 64898, 65048, 65177, 65287, 65376, 65446, 65496, 65526,\n};\n\n\nstatic inline Fixed32 sin_deg(Fixed32 angle) {\n    int deg = (int)(angle >> FIXED_SHIFT);\n    deg %= 360; if (deg < 0) deg += 360;\n    return sin_table[deg];\n}\nstatic inline Fixed32 cos_deg(Fixed32 angle) {\n    int deg = (int)(angle >> FIXED_SHIFT);\n    deg %= 360; if (deg < 0) deg += 360;\n    return cos_table[deg];\n}\n\n\nstatic inline Fixed32 sin_deg_int(int deg) {\n    deg %= 360;\n    if (deg < 0) deg += 360;\n    return sin_table[deg];\n}\nstatic inline Fixed32 cos_deg_int(int deg) {\n    deg %= 360;\n    if (deg < 0) deg += 360;\n    return cos_table[deg];\n}\n\n\n#define INT_TO_FIXED(x)     ((Fixed32)(x) << FIXED_SHIFT)\n#define FIXED_TO_INT(x)     ((int)((x) >> FIXED_SHIFT))\n\nstatic inline int FIXED_ROUND_TO_INT(Fixed32 x) {\n    if (x >= 0) return (int)(((x) + FIXED_HALF) >> FIXED_SHIFT);\n    else return (int)(((x) - FIXED_HALF) >> FIXED_SHIFT);\n}\n#define FLOAT_TO_FIXED(x)   ((Fixed32)((x) * FIXED_SCALE))\n#define FIXED_TO_FLOAT(x)   ((float)(x) / (float)FIXED_SCALE)\n\n\n#define FIXED_ADD(a, b)     ((a) + (b))\n#define FIXED_SUB(a, b)     ((a) - (b))\n#define FIXED_NEG(x)        (-(x))\n#define FIXED_ABS(x)        ((x) >= 0 ? (x) : -(x))\n#define FIXED_FRAC(x)       ((x) & FIXED_MASK)\n\n\n#define FIXED_MUL(a, b)     (((long)(a) * (long)(b)) >> FIXED_SHIFT)\n#define FIXED_DIV(a, b)     (((long)(a) << FIXED_SHIFT) / (long)(b))\n\n\n#define FIXED_MUL_64(a, b)  ((Fixed32)(((Fixed64)(a) * (Fixed64)(b)) >> FIXED_SHIFT))\n#define FIXED_DIV_64(a, b)  ((Fixed32)(((Fixed64)(a) << FIXED_SHIFT) / (Fixed64)(b)))\n#define FIXED64_TO_32(x)    ((Fixed32)(x))\n\n\n\n\nstatic inline int normalize_deg(int deg) {\n    deg %= 360;\n    if (deg < 0) deg += 360;\n    return deg;\n}\n\n\n\n\n#define ENABLE_DEBUG_SAVE 0\n\n\n#define PERFORMANCE_MODE 0\n\n#define MAX_LINE_LENGTH 256\n#define MAX_VERTICES 6000\n#define MAX_FACES 6000\n#define MAX_FACE_VERTICES 6\n#define PI 3.14159265359\n#define CENTRE_X 160\n#define CENTRE_Y 100\n\n#define mode 320\n\n\n\n\n\n\n\ntypedef struct {\n    Handle xHandle, yHandle, zHandle;\n    Handle xoHandle, yoHandle, zoHandle;\n    Handle x2dHandle, y2dHandle;\n    Fixed32 *x, *y, *z;\n    Fixed32 *xo, *yo, *zo;\n    int *x2d, *y2d;\n    int vertex_count;\n} VertexArrays3D;\n\n\ntypedef struct {\n    Handle vertex_countHandle;\n    Handle vertex_indicesBufferHandle;\n    Handle vertex_indicesPtrHandle;\n    Handle z_maxHandle;\n    Handle display_flagHandle;\n    Handle sorted_face_indicesHandle;\n    \n    int *vertex_count;\n    int *vertex_indices_buffer;\n    int *vertex_indices_ptr;\n    Fixed32 *z_min;\n    Fixed32 *z_max;\n    Fixed32 *z_mean;\n    Fixed32 *plane_a;\n    Fixed32 *plane_b;\n    Fixed32 *plane_c;\n    Fixed32 *plane_d;\n    int *minx;\n    int *maxx;\n    int *miny;\n    int *maxy;\n    int *display_flag;\n    int *sorted_face_indices;\n    int face_count;\n    int total_indices;\n} FaceArrays3D;\n\n\ntypedef struct {\n    int vertex_count;\n    int vertex_indices[MAX_FACE_VERTICES];\n    Fixed32 z_max;\n    int display_flag;\n} Face3D;\n\n\ntypedef struct {\n    int polySize;\n    Rect polyBBox;\n    Point polyPoints[MAX_FACE_VERTICES];\n} DynamicPolygon;\n\n\n *   - Angles are in degrees (converted to radians for calculations)\n *   - Distance affects perspective and apparent size\n *   - angle_w allows final rotation to adjust orientation\n */\ntypedef struct {\n    int angle_h;\n    int angle_v;\n    int angle_w;\n    Fixed32 distance;\n} ObserverParams;\n\n\ntypedef struct {\n    VertexArrays3D vertices;          \n    FaceArrays3D faces;               \n} Model3D;\n\n\n\n\nFixed32 sin_fixed(Fixed32 angle);\nFixed32 cos_fixed(Fixed32 angle);\n\n\n\n\n\n\n\nvoid transformToObserver(VertexArrays3D* vtx, int angle_h_deg, int angle_v_deg, Fixed32 distance);\n\n\n\nvoid projectTo2D(VertexArrays3D* vtx, int angle_w_deg);\n\n\n\n\nvoid drawPolygons(Model3D* model, int* vertex_count, int face_count, int vertex_count_total);\n\nvoid calculateFaceDepths(Model3D* model, Face3D* faces, int face_count);\n\n\n\n\n\nstatic FaceArrays3D* qsort_faces_ptr_for_cmp = NULL;\nstatic int cmp_faces_by_zmean(const void* pa, const void* pb) {\n    int a = *(const int*)pa;\n    int b = *(const int*)pb;\n    Fixed32 za = qsort_faces_ptr_for_cmp->z_mean[a];\n    Fixed32 zb = qsort_faces_ptr_for_cmp->z_mean[b];\n    if (za > zb) return -1;   \n    if (za < zb) return 1;\n    if (a < b) return -1;     \n    if (a > b) return 1;\n    return 0;\n}\n\n\nvoid painter_newell_sancha(Model3D* model, int face_count) {\n    \n    FaceArrays3D* faces = &model->faces;\n    VertexArrays3D* vtx = &model->vertices;\n    int i, j;\n    Fixed32* face_zmean = faces->z_mean;\n    if (!face_zmean) return;\n\n\n    long t_start = GetTick();\n    for (i = 0; i < face_count; i++) faces->sorted_face_indices[i] = i;\n    qsort_faces_ptr_for_cmp = faces;\n    qsort(faces->sorted_face_indices, face_count, sizeof(int), cmp_faces_by_zmean);\n    qsort_faces_ptr_for_cmp = NULL;\n    long t_end = GetTick();\n    if (!PERFORMANCE_MODE)\n    {\n        long elapsed = t_end - t_start;\n            double ms = ((double)elapsed * 1000.0) / 60.0;\n    \n    \n    int swapped;\n    int swap_count = 0;\n\n\n    \n    typedef struct {\n        int face1;  \n        int face2;  \n    } OrderedPair;\n    \n    \n    \n    int ordered_pairs_capacity = face_count * 4;\n    OrderedPair* ordered_pairs = NULL;\n    if (ordered_pairs_capacity > 0) {\n        ordered_pairs = (OrderedPair*)malloc(ordered_pairs_capacity * sizeof(OrderedPair));\n        if (!ordered_pairs) {\n            \n            ordered_pairs_capacity = 0;\n        }\n    }\n    int ordered_pairs_count = 0;\n    \n    do {\n        swapped = 0;\n\n        for (i = 0; i < face_count-1; i++) {\n            int f1 = faces->sorted_face_indices[i];\n            int f2 = faces->sorted_face_indices[i+1];\n            \n            \n            \n            int already_ordered = 0;\n            int p;\n            for (p = 0; p < ordered_pairs_count; p++) {\n                if (ordered_pairs[p].face1 == f1 && ordered_pairs[p].face2 == f2) {\n                    already_ordered = 1;\n                    break;\n                }\n            }\n            if (already_ordered) {\n                continue;\n            }\n\n            \n\n            \n            if (faces->z_max[f2] >= faces->z_min[f1]) continue;\n            \n            \n            \n            int minx1 = faces->minx[f1], maxx1 = faces->maxx[f1], miny1 = faces->miny[f1], maxy1 = faces->maxy[f1];\n            int minx2 = faces->minx[f2], maxx2 = faces->maxx[f2], miny2 = faces->miny[f2], maxy2 = faces->maxy[f2];\n        \n            \n\n            if (maxx1 < minx2 || maxx2 < minx1) continue;\n            \n            \n\n            if (maxy1 < miny2 || maxy2 < miny1) continue;\n\n            \n            int n1 = faces->vertex_count[f1];\n            int n2 = faces->vertex_count[f2];\n            int offset1 = faces->vertex_indices_ptr[f1];\n            int offset2 = faces->vertex_indices_ptr[f2];\n            int k;\n            Fixed32 a1 = faces->plane_a[f1];\n            Fixed32 b1 = faces->plane_b[f1];\n            Fixed32 c1 = faces->plane_c[f1];\n            Fixed32 d1 = faces->plane_d[f1];\n            Fixed32 a2 = faces->plane_a[f2];\n            Fixed32 b2 = faces->plane_b[f2];\n            Fixed32 c2 = faces->plane_c[f2];\n            Fixed32 d2 = faces->plane_d[f2];\n            Fixed32 epsilon = FLOAT_TO_FIXED(0.01);\n\n            int obs_side1 = 0; \n            int obs_side2 = 0; \n            int side;           \n            int all_same_side; \n            int all_opposite_side; \n            Fixed32 test_value;\n\n\n            \n\n            \n\n            \n            obs_side1 = 0; \n            if (d1 > epsilon) obs_side1 = 1; \n            else if (d1 < -epsilon) obs_side1 = -1;\n            else goto skipT4; \n            all_same_side = 1;\n            for (k=0; k<n2; k++) {\n                    int v = faces->vertex_indices_buffer[offset2+k]-1;\n                    test_value = a1*vtx->xo[v] + b1*vtx->yo[v] + c1*vtx->zo[v] + d1;\n                    if  (test_value > epsilon) side = 1;\n                    else if (test_value < -epsilon) side = -1;\n                    if (obs_side1 != side) { \n                        \n                        \n                        all_same_side = 0;   \n                        break; \n                    }\n            }\n            if (all_same_side) continue; \n\n            skipT4:\n\n            \n\n            \n            obs_side2 = 0; \n            if (d2 > epsilon) obs_side2 = 1; \n            else if (d2 < -epsilon) obs_side2 = -1;\n            else goto skipT5; \n            all_opposite_side = 1;\n            for (k=0; k<n1; k++) {\n                int v = faces->vertex_indices_buffer[offset1+k]-1;\n                test_value = a2*vtx->xo[v] + b2*vtx->yo[v] + c2*vtx->zo[v] + d2;\n                if  (test_value > epsilon) side = 1;\n                else if (test_value < -epsilon) side = -1;\n                if (obs_side2 == side) {\n                    \n                    \n                    all_opposite_side = 0; \n                    break; }\n                }\n                if (all_opposite_side) continue; \n            \n            skipT5:\n\n            \n\n            \n            obs_side1 = 0; \n            if (d1 > epsilon) obs_side1 = 1; \n            else if (d1 < -epsilon) obs_side1 = -1;\n            else goto skipT6; \n\n                all_opposite_side = 1;\n                for (k=0; k<n2; k++) {\n                    int v = faces->vertex_indices_buffer[offset2+k]-1;\n                    int side;\n                    if  ((a1*vtx->xo[v] + b1*vtx->yo[v] + c1*vtx->zo[v] + d1) > epsilon) side = 1;\n                    else side = -1;\n                    if (obs_side1 == side) { \n                        all_opposite_side = 0; \n                        break; \n                        }\n                }\n                if (all_opposite_side == 0) continue;\n                \n\n                \n                \n                else {\n                    goto do_swap;\n                }\n\n            skipT6: ;\n\n            \n\n            \n            obs_side2 = 0; \n            if (d2 > epsilon) obs_side2 = 1; \n            else if (d2 < -epsilon) obs_side2 = -1;\n            else goto skipT7; \n            all_same_side = 1;\n            for (k=0; k<n1; k++) {\n                int v = faces->vertex_indices_buffer[offset1+k]-1;\n                int side;\n                if  ((a2*vtx->xo[v] + b2*vtx->yo[v] + c2*vtx->zo[v] + d2) > epsilon) side = 1;\n                else side = -1;\n                if (obs_side2 != side) { \n                    all_same_side = 0; \n                    break; \n                    }\n            }\n                if (all_same_side == 0) continue;\n                \n                \n                else {\n                    goto do_swap;\n                }\n\n            do_swap: {\n\n                int tmp = faces->sorted_face_indices[i];\n                faces->sorted_face_indices[i] = faces->sorted_face_indices[i+1];\n                faces->sorted_face_indices[i+1] = tmp;\n                swapped = 1;\n                swap_count++;\n                \n                \n                \n                \n                if (ordered_pairs != NULL && ordered_pairs_count < ordered_pairs_capacity) {\n                    ordered_pairs[ordered_pairs_count].face1 = f2;\n                    ordered_pairs[ordered_pairs_count].face2 = f1;\n                    ordered_pairs_count++;\n                }\n            }\n\n        skipT7: ;\n        \n        }\n            } while (swapped);\n    \n\n\n    \n    if (ordered_pairs) {\n        free(ordered_pairs);\n    }    \n}\n\n\n\n
\n\n\n\nFixed32 sin_fixed(Fixed32 angle) {\n    while (angle > FIXED_PI) angle = FIXED_SUB(angle, FIXED_2PI);\n    while (angle < -FIXED_PI) angle = FIXED_ADD(angle, FIXED_2PI);\n    \n    Fixed32 x = angle;\n    Fixed32 x2 = FIXED_MUL_64(x, x);       \n    Fixed32 x3 = FIXED_MUL_64(x2, x);      \n    Fixed32 x5 = FIXED_MUL_64(x3, x2);     \n    Fixed32 x7 = FIXED_MUL_64(x5, x2);     \n    \n    Fixed32 result = x;\n    result = FIXED_SUB(result, FIXED_DIV_64(x3, INT_TO_FIXED(6))); \n    result = FIXED_ADD(result, FIXED_DIV_64(x5, INT_TO_FIXED(120))); \n    result = FIXED_SUB(result, FIXED_DIV_64(x7, INT_TO_FIXED(5040))); \n    \n    return result;\n}\n\n\nFixed32 cos_fixed(Fixed32 angle) {\n    return sin_fixed(FIXED_ADD(angle, FIXED_PI_2));\n}\n
\n\n\n\nModel3D* createModel3D(void) {\n    \n    Model3D* model = (Model3D*)malloc(sizeof(Model3D));\n    if (model == NULL) {\n        return NULL;\n    }\n    int n = MAX_VERTICES;\n    model->vertices.vertex_count = n;\n    \n    \n    \n    model->vertices.x = (Fixed32*)malloc(n * sizeof(Fixed32));\n    model->vertices.y = (Fixed32*)malloc(n * sizeof(Fixed32));\n    model->vertices.z = (Fixed32*)malloc(n * sizeof(Fixed32));\n    model->vertices.xo = (Fixed32*)malloc(n * sizeof(Fixed32));\n    model->vertices.yo = (Fixed32*)malloc(n * sizeof(Fixed32));\n    model->vertices.zo = (Fixed32*)malloc(n * sizeof(Fixed32));\n    model->vertices.x2d = (int*)malloc(n * sizeof(int));\n    model->vertices.y2d = (int*)malloc(n * sizeof(int));\n    \n    if (!model->vertices.x || !model->vertices.y || !model->vertices.z ||\n        !model->vertices.xo || !model->vertices.yo || !model->vertices.zo ||\n        !model->vertices.x2d || !model->vertices.y2d) {\n        printf("Error: Unable to allocate memory for vertex arrays\n");\n        keypress();\n        \n        if (model->vertices.x) free(model->vertices.x);\n        if (model->vertices.y) free(model->vertices.y);\n        if (model->vertices.z) free(model->vertices.z);\n        if (model->vertices.xo) free(model->vertices.xo);\n        if (model->vertices.yo) free(model->vertices.yo);\n        if (model->vertices.zo) free(model->vertices.zo);\n        if (model->vertices.x2d) free(model->vertices.x2d);\n        if (model->vertices.y2d) free(model->vertices.y2d);\n        free(model);\n        return NULL;\n    }\n    \n    \n    model->vertices.xHandle = NULL;\n    model->vertices.yHandle = NULL;\n    model->vertices.zHandle = NULL;\n    model->vertices.xoHandle = NULL;\n    model->vertices.yoHandle = NULL;\n    model->vertices.zoHandle = NULL;\n    model->vertices.x2dHandle = NULL;\n    model->vertices.y2dHandle = NULL;\n    \n    \n    \n    int nf = MAX_FACES;\n    \n    \n    model->faces.vertex_count = (int*)malloc(nf * sizeof(int));\n    if (!model->faces.vertex_count) {\n        printf("Error: Unable to allocate memory for face vertex_count array\n");\n        keypress();\n        free(model->vertices.x);\n        free(model->vertices.y);\n        free(model->vertices.z);\n        free(model->vertices.xo);\n        free(model->vertices.yo);\n        free(model->vertices.zo);\n        free(model->vertices.x2d);\n        free(model->vertices.y2d);\n        free(model);\n        return NULL;\n    }\n    \n    \n    \n    \n    int estimated_total_indices = nf * 5;\n    model->faces.vertex_indices_buffer = (int*)malloc(estimated_total_indices * sizeof(int));\n    if (!model->faces.vertex_indices_buffer) {\n        printf("Error: Unable to allocate memory for vertex_indices_buffer\n");\n        keypress();\n        free(model->vertices.x);\n        free(model->vertices.y);\n        free(model->vertices.z);\n        free(model->vertices.xo);\n        free(model->vertices.yo);\n        free(model->vertices.zo);\n        free(model->vertices.x2d);\n        free(model->vertices.y2d);\n        free(model->faces.vertex_count);\n        free(model);\n        return NULL;\n    }\n    \n    \n    model->faces.vertex_indices_ptr = (int*)malloc(nf * sizeof(int));\n    if (!model->faces.vertex_indices_ptr) {\n        printf("Error: Unable to allocate memory for vertex_indices_ptr array\n");\n        keypress();\n        free(model->vertices.x);\n        free(model->vertices.y);\n        free(model->vertices.z);\n        free(model->vertices.xo);\n        free(model->vertices.yo);\n        free(model->vertices.zo);\n        free(model->vertices.x2d);\n        free(model->vertices.y2d);\n        free(model->faces.vertex_count);\n        free(model->faces.vertex_indices_buffer);\n        free(model);\n        return NULL;\n    }\n    \n    \n    model->faces.z_min = (Fixed32*)malloc(nf * sizeof(Fixed32));\n    model->faces.z_max = (Fixed32*)malloc(nf * sizeof(Fixed32));\n    if (!model->faces.z_min || !model->faces.z_max) {\n        printf("Error: Unable to allocate memory for face depth arrays\n");\n        keypress();\n        if (model->faces.z_min) free(model->faces.z_min);\n        if (model->faces.z_max) free(model->faces.z_max);\n        free(model->vertices.x);\n        free(model->vertices.y);\n        free(model->vertices.z);\n        free(model->vertices.xo);\n        free(model->vertices.yo);\n        free(model->vertices.zo);\n        free(model->vertices.x2d);\n        free(model->vertices.y2d);\n        free(model->faces.vertex_count);\n        free(model->faces.vertex_indices_buffer);\n        free(model->faces.vertex_indices_ptr);\n        free(model);\n        return NULL;\n    }\n    \n    model->faces.z_mean = (Fixed32*)malloc(nf * sizeof(Fixed32));\n    if (!model->faces.z_mean) {\n        printf("Error: Unable to allocate memory for face z_mean array\n");\n        keypress();\n        if (model->faces.z_mean) free(model->faces.z_mean);\n        free(model->vertices.x);\n        free(model->vertices.y);\n        free(model->vertices.z);\n        free(model->vertices.xo);\n        free(model->vertices.yo);\n        free(model->vertices.zo);\n        free(model->vertices.x2d);\n        free(model->vertices.y2d);\n        free(model->faces.vertex_count);\n        free(model->faces.vertex_indices_buffer);\n        free(model->faces.vertex_indices_ptr);\n        if (model->faces.z_min) free(model->faces.z_min);\n        if (model->faces.z_max) free(model->faces.z_max);\n        free(model);\n        return NULL;\n    }\n\n    \n    model->faces.plane_a = (Fixed32*)malloc(nf * sizeof(Fixed32));\n    model->faces.plane_b = (Fixed32*)malloc(nf * sizeof(Fixed32));\n    model->faces.plane_c = (Fixed32*)malloc(nf * sizeof(Fixed32));\n    model->faces.plane_d = (Fixed32*)malloc(nf * sizeof(Fixed32));\n    if (!model->faces.plane_a || !model->faces.plane_b || !model->faces.plane_c || !model->faces.plane_d) {\n        printf("Error: Unable to allocate memory for face plane arrays\n");\n        keypress();\n        if (model->faces.plane_a) free(model->faces.plane_a);\n        if (model->faces.plane_b) free(model->faces.plane_b);\n        if (model->faces.plane_c) free(model->faces.plane_c);\n        if (model->faces.plane_d) free(model->faces.plane_d);\n        if (model->faces.z_mean) free(model->faces.z_mean);\n        if (model->faces.z_min) free(model->faces.z_min);\n        if (model->faces.z_max) free(model->faces.z_max);\n        free(model->vertices.x);\n        free(model->vertices.y);\n        free(model->vertices.z);\n        free(model->vertices.xo);\n        free(model->vertices.yo);\n        free(model->vertices.zo);\n        free(model->vertices.x2d);\n        free(model->vertices.y2d);\n        free(model->faces.vertex_count);\n        free(model->faces.vertex_indices_buffer);\n        free(model->faces.vertex_indices_ptr);\n        free(model->faces.z_max);\n        free(model);\n        return NULL;\n    }\n\n    \n    model->faces.minx = (int*)malloc(nf * sizeof(int));\n    model->faces.maxx = (int*)malloc(nf * sizeof(int));\n    model->faces.miny = (int*)malloc(nf * sizeof(int));\n    model->faces.maxy = (int*)malloc(nf * sizeof(int));\n    if (!model->faces.minx || !model->faces.maxx || !model->faces.miny || !model->faces.maxy) {\n        printf("Error: Unable to allocate memory for face bounding box arrays\n");\n        keypress();\n        if (model->faces.minx) free(model->faces.minx);\n        if (model->faces.maxx) free(model->faces.maxx);\n        if (model->faces.miny) free(model->faces.miny);\n        if (model->faces.maxy) free(model->faces.maxy);\n        if (model->faces.plane_a) free(model->faces.plane_a);\n        if (model->faces.plane_b) free(model->faces.plane_b);\n        if (model->faces.plane_c) free(model->faces.plane_c);\n        if (model->faces.plane_d) free(model->faces.plane_d);\n        if (model->faces.z_mean) free(model->faces.z_mean);\n        if (model->faces.z_min) free(model->faces.z_min);\n        if (model->faces.z_max) free(model->faces.z_max);\n        free(model->vertices.x);\n        free(model->vertices.y);\n        free(model->vertices.z);\n        free(model->vertices.xo);\n        free(model->vertices.yo);\n        free(model->vertices.zo);\n        free(model->vertices.x2d);\n        free(model->vertices.y2d);\n        free(model->faces.vertex_count);\n        free(model->faces.vertex_indices_buffer);\n        free(model->faces.vertex_indices_ptr);\n        free(model->faces.z_max);\n        free(model);\n        return NULL;\n    }\n    \n    \n    model->faces.display_flag = (int*)malloc(nf * sizeof(int));\n    if (!model->faces.display_flag) {\n        printf("Error: Unable to allocate memory for face display_flag array\n");\n        keypress();\n        free(model->vertices.x);\n        free(model->vertices.y);\n        free(model->vertices.z);\n        free(model->vertices.xo);\n        free(model->vertices.yo);\n        free(model->vertices.zo);\n        free(model->vertices.x2d);\n        free(model->vertices.y2d);\n        free(model->faces.vertex_count);\n        free(model->faces.vertex_indices_buffer);\n        free(model->faces.vertex_indices_ptr);\n        free(model->faces.z_max);\n        if (model->faces.z_mean) free(model->faces.z_mean);\n        free(model);\n        return NULL;\n    }\n    \n    \n    model->faces.vertex_countHandle = NULL;\n    model->faces.vertex_indicesBufferHandle = NULL;\n    model->faces.vertex_indicesPtrHandle = NULL;\n    model->faces.z_maxHandle = NULL;\n    model->faces.display_flagHandle = NULL;\n    model->faces.sorted_face_indicesHandle = NULL;\n    model->faces.total_indices = 0;\n    \n    \n    model->faces.sorted_face_indices = (int*)malloc(nf * sizeof(int));\n    if (!model->faces.sorted_face_indices) {\n        printf("Error: Unable to allocate memory for sorted_face_indices array\n");\n        keypress();\n        free(model->vertices.x);\n        free(model->vertices.y);\n        free(model->vertices.z);\n        free(model->vertices.xo);\n        free(model->vertices.yo);\n        free(model->vertices.zo);\n        free(model->vertices.x2d);\n        free(model->vertices.y2d);\n        free(model->faces.vertex_count);\n        free(model->faces.vertex_indices_buffer);\n        free(model->faces.vertex_indices_ptr);\n        if (model->faces.z_min) free(model->faces.z_min);\n        if (model->faces.z_max) free(model->faces.z_max);\n        if (model->faces.z_mean) free(model->faces.z_mean);\n        free(model->faces.display_flag);\n        free(model);\n        return NULL;\n    }\n    \n    \n    model->faces.vertex_countHandle = NULL;\n    model->faces.vertex_indicesBufferHandle = NULL;\n    model->faces.vertex_indicesPtrHandle = NULL;\n    model->faces.z_maxHandle = NULL;\n    model->faces.display_flagHandle = NULL;\n    model->faces.sorted_face_indicesHandle = NULL;\n    model->faces.total_indices = 0;\n    \n    return model;\n}\n\n\nvoid destroyModel3D(Model3D* model) {\n    if (model != NULL) {\n        \n        if (model->vertices.x) free(model->vertices.x);\n        if (model->vertices.y) free(model->vertices.y);\n        if (model->vertices.z) free(model->vertices.z);\n        if (model->vertices.xo) free(model->vertices.xo);\n        if (model->vertices.yo) free(model->vertices.yo);\n        if (model->vertices.zo) free(model->vertices.zo);\n        if (model->vertices.x2d) free(model->vertices.x2d);\n        if (model->vertices.y2d) free(model->vertices.y2d);\n        \n        \n        if (model->faces.vertex_count) free(model->faces.vertex_count);\n        if (model->faces.vertex_indices_buffer) free(model->faces.vertex_indices_buffer);\n        if (model->faces.vertex_indices_ptr) free(model->faces.vertex_indices_ptr);\n        if (model->faces.z_max) free(model->faces.z_max);\n        if (model->faces.z_mean) free(model->faces.z_mean);\n        if (model->faces.z_min) free(model->faces.z_min);\n        if (model->faces.z_max) free(model->faces.z_max);\n        if (model->faces.plane_a) free(model->faces.plane_a);\n        if (model->faces.plane_b) free(model->faces.plane_b);\n        if (model->faces.plane_c) free(model->faces.plane_c);\n        if (model->faces.plane_d) free(model->faces.plane_d);\n        if (model->faces.minx) free(model->faces.minx);\n        if (model->faces.maxx) free(model->faces.maxx);\n        if (model->faces.miny) free(model->faces.miny);\n        if (model->faces.maxy) free(model->faces.maxy);\n        if (model->faces.display_flag) free(model->faces.display_flag);\n        if (model->faces.sorted_face_indices) free(model->faces.sorted_face_indices);\n        \n        \n        free(model);\n    }\n}\n\n\nint loadModel3D(Model3D* model, const char* filename) {\n    \n    if (model == NULL || filename == NULL) {\n        return -1;  \n    }\n    \n    \n    \n    readVertices_last_count = model->vertices.vertex_count;\n    \n    int vcount = readVertices(filename, &model->vertices, MAX_VERTICES);\n    if (vcount < 0) {\n        return -1;  \n    }\n    model->vertices.vertex_count = vcount;\n    \n    \n    \n    int fcount = readFaces_model(filename, model);\n    if (fcount < 0) {\n        \n        printf("\nWarning: Unable to read faces\n");\n        model->faces.face_count = 0;  \n    } else {\n        model->faces.face_count = fcount;\n    }\n    \n    return 0;  \n}\n
\n\n\n\nvoid getObserverParams(ObserverParams* params) {\n    char input[50];  \n    \n    \n    printf("\nObserver parameters:\n");\n    printf("============================\n");\n    printf("(Press ENTER to use default values)\n");\n    printf("(Enter 'debug' to see values used)\n");\n    \n    \n    printf("Horizontal angle (degrees, default 30): ");\n    if (fgets(input, sizeof(input), stdin) != NULL) {\n        \n        input[strcspn(input, "\n")] = 0;\n        if (strlen(input) == 0) {\n            params->angle_h = 30;     \n        } else {\n            params->angle_h = atoi(input);  \n        }\n    } else {\n        params->angle_h = 30;         \n    }\n    \n    \n    printf("Vertical angle (degrees, default 20): ");\n    if (fgets(input, sizeof(input), stdin) != NULL) {\n        \n        input[strcspn(input, "\n")] = 0;\n        if (strlen(input) == 0) {\n            params->angle_v = 20;     \n        } else {\n            params->angle_v = atoi(input);  \n        }\n    } else {\n        params->angle_v = 20;         \n    }\n    \n\n    \n    printf("Screen rotation angle (degrees, default 0): ");\n    if (fgets(input, sizeof(input), stdin) != NULL) {\n        \n        input[strcspn(input, "\n")] = 0;\n        if (strlen(input) == 0) {\n            params->angle_w = 0;      \n        } else {\n            params->angle_w = atoi(input);  \n        }\n    } else {\n        params->angle_w = 0;          \n    }\n\n    \n    printf("Distance (default 30): ");\n    if (fgets(input, sizeof(input), stdin) != NULL) {\n        \n        input[strcspn(input, "\n")] = 0;\n        if (strlen(input) == 0) {\n            params->distance = FLOAT_TO_FIXED(30.0);    \n        } else {\n            params->distance = FLOAT_TO_FIXED(atof(input)); \n        }\n    } else {\n        params->distance = FLOAT_TO_FIXED(30.0);        \n    }\n\n    \n    printf("Observer angles (degrees) - H: %d, V: %d, W: %d\n", params->angle_h, params->angle_v, params->angle_w);\n}\n\n\n\nvoid processModelFast(Model3D* model, ObserverParams* params, const char* filename) {\n    int i;\n    Fixed32 rad_h, rad_v, rad_w;\n    Fixed32 cos_h, sin_h, cos_v, sin_v, cos_w, sin_w;\n    Fixed32 x, y, z, zo, xo, yo;\n    Fixed32 inv_zo, x2d_temp, y2d_temp;\n    \n    \n    cos_h = cos_deg_int(params->angle_h);\n    sin_h = sin_deg_int(params->angle_h);\n    cos_v = cos_deg_int(params->angle_v);\n    sin_v = sin_deg_int(params->angle_v);\n    cos_w = cos_deg_int(params->angle_w);\n    sin_w = sin_deg_int(params->angle_w);\n\n    \n    const Fixed32 cos_h_cos_v = FIXED_MUL_64(cos_h, cos_v);\n    const Fixed32 sin_h_cos_v = FIXED_MUL_64(sin_h, cos_v);\n    const Fixed32 cos_h_sin_v = FIXED_MUL_64(cos_h, sin_v);\n    const Fixed32 sin_h_sin_v = FIXED_MUL_64(sin_h, sin_v);\n    const Fixed32 scale = FLOAT_TO_FIXED(100.0);\n    const Fixed32 centre_x_f = FLOAT_TO_FIXED((float)CENTRE_X);\n    const Fixed32 centre_y_f = FLOAT_TO_FIXED((float)CENTRE_Y);\n    const Fixed32 distance = params->distance;\n    \n    \n    \n    \n    VertexArrays3D* vtx = &model->vertices;\n    \n    for (i = 0; i < vtx->vertex_count; i++) {\n        x = vtx->x[i];\n        y = vtx->y[i];\n        z = vtx->z[i];\n        \n        Fixed32 term1 = FIXED_MUL_64(x, cos_h_cos_v);\n        Fixed32 term2 = FIXED_MUL_64(y, sin_h_cos_v);\n        Fixed32 term3 = FIXED_MUL_64(z, sin_v);\n        zo = FIXED_ADD(FIXED_SUB(FIXED_SUB(FIXED_NEG(term1), term2), term3), distance);\n        if (zo > 0) {\n            xo = FIXED_ADD(FIXED_NEG(FIXED_MUL_64(x, sin_h)), FIXED_MUL_64(y, cos_h));\n            yo = FIXED_ADD(FIXED_SUB(FIXED_NEG(FIXED_MUL_64(x, cos_h_sin_v)), FIXED_MUL_64(y, sin_h_sin_v)), FIXED_MUL_64(z, cos_v));\n            vtx->zo[i] = zo;\n            vtx->xo[i] = xo;\n            vtx->yo[i] = yo;\n            inv_zo = FIXED_DIV_64(scale, zo);\n            x2d_temp = FIXED_ADD(FIXED_MUL_64(xo, inv_zo), centre_x_f);\n            y2d_temp = FIXED_SUB(centre_y_f, FIXED_MUL_64(yo, inv_zo));\n            vtx->x2d[i] = FIXED_ROUND_TO_INT(FIXED_ADD(FIXED_SUB(FIXED_MUL_64(cos_w, FIXED_SUB(x2d_temp, centre_x_f)), FIXED_MUL_64(sin_w, FIXED_SUB(centre_y_f, y2d_temp))), centre_x_f));\n            vtx->y2d[i] = FIXED_ROUND_TO_INT(FIXED_SUB(centre_y_f, FIXED_ADD(FIXED_MUL_64(sin_w, FIXED_SUB(x2d_temp, centre_x_f)), FIXED_MUL_64(cos_w, FIXED_SUB(centre_y_f, y2d_temp)))));\n        } else {\n            vtx->zo[i] = zo;\n            vtx->xo[i] = 0;\n            vtx->yo[i] = 0;\n            vtx->x2d[i] = -1;\n            vtx->y2d[i] = -1;\n        }\n    }\n    \n\n    \n    \n    long t_start, t_end;\n\n    t_start = GetTick();\n    calculateFaceDepths(model, NULL, model->faces.face_count);\n    t_end = GetTick();\n    {\n        long elapsed = t_end - t_start;\n        double ms = ((double)elapsed * 1000.0) / 60.0; \n        printf("[TIMING] calculateFaceDepths: %ld ticks (%.2f ms)\n", elapsed, ms);\n    }\n\n    \n    \n    for (i = 0; i < model->faces.face_count; i++) {\n        model->faces.sorted_face_indices[i] = i;\n    }\n\n    \n    t_start = GetTick();\n    painter_newell_sancha(model, model->faces.face_count);\n    t_end = GetTick();\n\n    if (!PERFORMANCE_MODE)\n    {\n        long elapsed = t_end - t_start;\n        double ms = ((double)elapsed * 1000.0) / 60.0; \n        printf("[TIMING] painter_newell_sancha: %ld ticks (%.2f ms)\n", elapsed, ms);\n        keypress();\n    }\n}\n
\n\n\n\nint readVertices(const char* filename, VertexArrays3D* vtx, int max_vertices) {\n    FILE *file;\n    char line[MAX_LINE_LENGTH];\n    int line_number = 1;\n    int vertex_count = 0;\n    \n    \n    file = fopen(filename, "r");\n    if (file == NULL) {\n        printf("[DEBUG] readVertices: fopen failed\n");\n        printf("Error: Unable to open file '%s'\n", filename);\n        printf("Check that the file exists and you have read permissions.\n");\n        return -1;\n    }\n    \n    printf("\nReading vertices from file...'%s':\n", filename);\n    \n    \n    while (fgets(line, sizeof(line), file) != NULL) {\n        if (line[0] == 'v' && line[1] == ' ') {\n            if (vertex_count < max_vertices) {\n                float x, y, z;\n                if (sscanf(line + 2, "%f %f %f", &x, &y, &z) == 3) {\n                    vtx->x[vertex_count] = FLOAT_TO_FIXED(x);\n                    vtx->y[vertex_count] = FLOAT_TO_FIXED(y);\n                    vtx->z[vertex_count] = FLOAT_TO_FIXED(z);\n                    vertex_count++;\n                    if (vertex_count % 10 == 0) printf("..");\n\n                } else {\n                    printf("[\nDEBUG] readVertices: sscanf failed at line %d: %s\n", line_number, line);\n                    keypress();\n                }\n            } else {\n                printf("\n[DEBUG] readVertices: vertex limit reached (%d)\n", max_vertices);\n                keypress();\n            }\n        }\n        line_number++;\n    }\n    printf("\n");\n    printf("Reading vertices finished : %d vertices read.\n", vertex_count);\n\n    \n    fclose(file);\n    \n    return vertex_count;\n}\n\nint readFaces_model(const char* filename, Model3D* model) {\n    FILE *file;\n    char line[MAX_LINE_LENGTH];\n    int line_number = 1;\n    int face_count = 0;\n    int i;\n    \n    if (model == NULL || model->faces.vertex_count == NULL) {\n        printf("Error: Invalid model structure for readFaces_model\n");\n        return -1;\n    }\n    \n    \n    file = fopen(filename, "r");\n    if (file == NULL) {\n        printf("Error: Unable to open file '%s' to read faces\n", filename);\n        return -1;\n    }\n    \n    printf("\nReading faces from file '%s' :\n", filename);\n    \n    int buffer_pos = 0;\n    \n    \n    while (fgets(line, sizeof(line), file) != NULL) {\n        if (line[0] == 'f' && line[1] == ' ') {\n            if (face_count < MAX_FACES) {\n                model->faces.vertex_count[face_count] = 0;\n                model->faces.display_flag[face_count] = 1;\n                model->faces.vertex_indices_ptr[face_count] = buffer_pos;\n                \n                char *ptr = line + 2;\n                int temp_indices[MAX_FACE_VERTICES];\n                int temp_vertex_count = 0;\n                int invalid_index_found = 0;\n                \n                \n                while (*ptr != '\0' && *ptr != '\n' && temp_vertex_count < MAX_FACE_VERTICES) {\n                    while (*ptr == ' ' || *ptr == '\t') ptr++;\n                    \n                    if (*ptr == '\0' || *ptr == '\n') break;\n                    \n                    int vertex_index = 0;\n                    while (*ptr >= '0' && *ptr <= '9') {\n                        vertex_index = vertex_index * 10 + (*ptr - '0');\n                        ptr++;\n                    }\n                    \n                    while (*ptr != '\0' && *ptr != ' ' && *ptr != '\t' && *ptr != '\n') {\n                        ptr++;\n                    }\n                    \n                    if (vertex_index >= 1) {\n                        if (vertex_index > readVertices_last_count) {\n                            invalid_index_found = 1;\n                        }\n                        temp_indices[temp_vertex_count] = vertex_index;\n                        temp_vertex_count++;\n                    }\n                }\n                \n                if (invalid_index_found) {\n                    printf("\nERROR: Face at line %d references vertex index > %d vertices\n", \n                           line_number, readVertices_last_count);\n                    fclose(file);\n                    return -1;\n                } else {\n                    for (i = 0; i < temp_vertex_count; i++) {\n                        model->faces.vertex_indices_buffer[buffer_pos++] = temp_indices[i];\n                    }\n                    model->faces.vertex_count[face_count] = temp_vertex_count;\n                    model->faces.total_indices += temp_vertex_count;\n                    \n                    if (model->faces.vertex_count[face_count] > 0) {\n                        face_count++;\n                        if (face_count % 10 == 0) {printf(".");}\n                    } else {\n                        printf("     -> WARNING: Face without valid vertices ignored\n");\n                    }\n                }\n            } else {\n                printf("     -> WARNING: Face limit reached (%d)\n", MAX_FACES);\n            }\n        }\n        \n        line_number++;\n    }\n    \n    \n    fclose(file);\n    \n    model->faces.face_count = face_count;\n    \n    for (i = 0; i < face_count; i++) {\n        model->faces.sorted_face_indices[i] = i;\n    }\n    \n    printf("\nReading faces finished : %d faces read.\n", face_count);\n    return face_count;\n}\n\nvoid transformToObserver(VertexArrays3D* vtx, int angle_h_deg, int angle_v_deg, Fixed32 distance) {\n    int i;\n    Fixed32 cos_h, sin_h, cos_v, sin_v;\n    Fixed32 x, y, z;\n    cos_h = cos_deg_int(angle_h_deg);\n    sin_h = sin_deg_int(angle_h_deg);\n    cos_v = cos_deg_int(angle_v_deg);\n    sin_v = sin_deg_int(angle_v_deg);\n    Fixed32 cos_h_cos_v = FIXED_MUL_64(cos_h, cos_v);\n    Fixed32 sin_h_cos_v = FIXED_MUL_64(sin_h, cos_v);\n    Fixed32 cos_h_sin_v = FIXED_MUL_64(cos_h, sin_v);\n    Fixed32 sin_h_sin_v = FIXED_MUL_64(sin_h, sin_v);\n\n    for (i = 0; i < vtx->vertex_count; i++) {\n        x = vtx->x[i];\n        z = vtx->z[i];\n        vtx->xo[i] = FIXED_ADD(\n            FIXED_MUL_64(x, cos_h_cos_v),\n            FIXED_MUL_64(y, sin_h_cos_v)\n        );\n        vtx->yo[i] = FIXED_ADD(\n            FIXED_SUB(\n                FIXED_MUL_64(-x, cos_h_sin_v),\n                FIXED_MUL_64(y, sin_h_sin_v)\n            ),\n            FIXED_MUL_64(z, cos_v)\n        );\n        vtx->zo[i] = FIXED_ADD(\n            FIXED_ADD(\n                FIXED_MUL_64(-x, sin_h),\n                FIXED_MUL_64(-y, cos_h)\n            ),\n            distance\n        );\n    }\n}\n\nvoid projectTo2D(VertexArrays3D* vtx, int angle_w_deg) {\n    int i;\n    Fixed32 cos_w, sin_w;\n    Fixed32 x2d_temp, y2d_temp;\n    cos_w = cos_deg_int(angle_w_deg);\n    sin_w = sin_deg_int(angle_w_deg);\n    const Fixed32 scale = INT_TO_FIXED(100);\n    const Fixed32 centre_x_f = INT_TO_FIXED(CENTRE_X);\n    const Fixed32 centre_y_f = INT_TO_FIXED(CENTRE_Y);\n\n    for (i = 0; i < vtx->vertex_count; i++) {\n        if (vtx->zo[i] > 0) {\n            Fixed32 xo = vtx->xo[i];\n            Fixed32 yo = vtx->yo[i];\n            Fixed32 inv_zo = FIXED_DIV_64(scale, vtx->zo[i]);\n            x2d_temp = FIXED_ADD(FIXED_MUL_64(xo, inv_zo), centre_x_f);\n            y2d_temp = FIXED_SUB(centre_y_f, FIXED_MUL_64(yo, inv_zo));\n            vtx->x2d[i] = FIXED_ROUND_TO_INT(FIXED_ADD(FIXED_SUB(FIXED_MUL_64(cos_w, FIXED_SUB(x2d_temp, centre_x_f)), FIXED_MUL_64(sin_w, FIXED_SUB(centre_y_f, y2d_temp))), centre_x_f));\n            vtx->y2d[i] = FIXED_ROUND_TO_INT(FIXED_SUB(centre_y_f, FIXED_ADD(FIXED_MUL_64(sin_w, FIXED_SUB(x2d_temp, centre_x_f)), FIXED_MUL_64(cos_w, FIXED_SUB(centre_y_f, y2d_temp)))));\n        } else {\n            vtx->x2d[i] = -1;\n            vtx->y2d[i] = -1;\n        }\n    }\n}\n\n\nvoid calculateFaceDepths(Model3D* model, Face3D* faces, int face_count) {\n    int i, j;\n    VertexArrays3D* vtx = &model->vertices;\n    FaceArrays3D* face_arrays = &model->faces;\n    \n    for (i = 0; i < face_count; i++) {\n        Fixed32 z_min = FLOAT_TO_FIXED(9999.0);\n        Fixed32 z_max = FLOAT_TO_FIXED(-9999.0);\n        int display_flag = 1;\n        Fixed32 sum = 0;\n        int n = face_arrays->vertex_count[i];\n        int minx = 9999, maxx = -9999, miny = 9999, maxy = -9999;\n        \n        int offset = face_arrays->vertex_indices_ptr[i];\n        for (j = 0; j < n; j++) {\n            int vertex_idx = face_arrays->vertex_indices_buffer[offset + j] - 1;\n            if (vertex_idx >= 0) {\n                Fixed32 zo = vtx->zo[vertex_idx];\n                if (zo <= 0) display_flag = 0;\n                if (zo < z_min) z_min = zo;\n                if (zo > z_max) z_max = zo;\n                sum += zo;\n                int x2d = vtx->x2d[vertex_idx];\n                int y2d = vtx->y2d[vertex_idx];\n                if (x2d < minx) minx = x2d;\n                if (x2d > maxx) maxx = x2d;\n                if (y2d < miny) miny = y2d;\n                if (y2d > maxy) maxy = y2d;\n            }\n        }\n        Fixed32 a = 0, b = 0, c = 0, d = 0;\n        if (n > 0) {\n            for (j = 0; j < n; j++) {\n                int idx1 = face_arrays->vertex_indices_buffer[offset + j] - 1;\n                int idx2 = face_arrays->vertex_indices_buffer[offset + ((j+1)%n)] - 1;\n                if (idx1 >= 0 && idx2 >= 0) {\n                    Fixed32 x1 = vtx->xo[idx1], y1 = vtx->yo[idx1], z1 = vtx->zo[idx1];\n                    Fixed32 x2 = vtx->xo[idx2], y2 = vtx->yo[idx2], z2 = vtx->zo[idx2];\n                    a += (y1 - y2) * (z1 + z2);\n                    b += (z1 - z2) * (x1 + x2);\n                    c += (x1 - x2) * (y1 + y2);\n                }\n            }\n            Fixed32 len_sq = a*a + b*b + c*c;\n            Fixed32 min_length_sq = FLOAT_TO_FIXED(0.01);\n            if (len_sq < min_length_sq) {\n                face_arrays->plane_a[i] = 0;\n                face_arrays->plane_b[i] = 0;\n                face_arrays->plane_c[i] = 0;\n                face_arrays->plane_d[i] = 0;\n            } else {\n                Fixed32 len = FLOAT_TO_FIXED(sqrt(FIXED_TO_FLOAT(len_sq)));\n                a = FIXED_DIV(a, len);\n                b = FIXED_DIV(b, len);\n                c = FIXED_DIV(c, len);\n                int v0 = face_arrays->vertex_indices_buffer[offset] - 1;\n                if (v0 >= 0) {\n                    d = FIXED_NEG(FIXED_ADD(FIXED_ADD(FIXED_MUL_64(a, vtx->xo[v0]), FIXED_MUL_64(b, vtx->yo[v0])), FIXED_MUL_64(c, vtx->zo[v0])));\n                } else d = 0;\n                face_arrays->plane_a[i] = a;\n                face_arrays->plane_b[i] = b;\n                face_arrays->plane_c[i] = c;\n                face_arrays->plane_d[i] = d;\n            }\n        } else {\n            face_arrays->plane_a[i] = 0;\n            face_arrays->plane_b[i] = 0;\n            face_arrays->plane_c[i] = 0;\n            face_arrays->plane_d[i] = 0;\n        }\n\n        face_arrays->z_min[i] = z_min;\n        face_arrays->z_max[i] = z_max;\n        face_arrays->display_flag[i] = display_flag;\n        if (n > 0) {\n            face_arrays->z_mean[i] = sum / n;\n            face_arrays->minx[i] = minx;\n            face_arrays->maxx[i] = maxx;\n            face_arrays->miny[i] = miny;\n            face_arrays->maxy[i] = maxy;\n        } else {\n            face_arrays->z_mean[i] = 0;\n            face_arrays->z_min[i] = 0;\n            face_arrays->z_max[i] = 0;\n            face_arrays->minx[i] = 0;\n            face_arrays->maxx[i] = 0;\n            face_arrays->miny[i] = 0;\n            face_arrays->maxy[i] = 0;\n        }\n    }\n}\n\n\n#define SWAP_FACE(faces, i, j) \\n    do { \\n        int temp_idx = faces->sorted_face_indices[i]; \\n        faces->sorted_face_indices[i] = faces->sorted_face_indices[j]; \\n        faces->sorted_face_indices[j] = temp_idx; \\n    } while (0)\n\n\n\nvoid drawPolygons(Model3D* model, int* vertex_count, int face_count, int vertex_count_total) {\n    int i, j;\n    VertexArrays3D* vtx = &model->vertices;\n    FaceArrays3D* faces = &model->faces;\n    Handle polyHandle;\n    DynamicPolygon *poly;\n    int min_x, max_x, min_y, max_y;\n    int valid_faces_drawn = 0;\n    int invalid_faces_skipped = 0;\n    int triangle_count = 0;\n    int quad_count = 0;\n    Pattern pat;\n    \n    if (globalPolyHandle == NULL) {\n        int max_polySize = 2 + 8 + (4 * 4);\n        globalPolyHandle = NewHandle((long)max_polySize, userid(), 0xC014, 0L);\n        if (globalPolyHandle == NULL) {\n            printf("Error: Unable to allocate global polygon handle\n");\n            return;\n        }\n    }\n    \n    polyHandle = globalPolyHandle;\n    \n    if (poly_handle_locked) {\n        HUnlock(polyHandle);\n        poly_handle_locked = 0;\n    }\n    HLock(polyHandle);\n    poly_handle_locked = 1;\n\n    SetPenMode(0);\n\n    \n    int start_face = 0;\n    int max_faces_to_draw = face_count;\n    for (i = start_face; i < start_face + max_faces_to_draw; i++) {\n        int face_id = faces->sorted_face_indices[i];\n        if (faces->display_flag[face_id] == 0) continue;\n        if (faces->vertex_count[face_id] >= 3) {\n            int offset = faces->vertex_indices_ptr[face_id];\n\n            \n            int polySize = 2 + 8 + (faces->vertex_count[face_id] * 4);\n            poly = (DynamicPolygon *)*polyHandle;\n            poly->polySize = polySize;\n            min_x = max_x = min_y = max_y = -1;\n            for (j = 0; j < faces->vertex_count[face_id]; j++) {\n                int vertex_idx = faces->vertex_indices_buffer[offset + j] - 1;\n                \n                if (vertex_idx >= 0 && vertex_idx < vtx->vertex_count) {\n                    poly->polyPoints[j].h = mode / 320 * vtx->x2d[vertex_idx];\n                    poly->polyPoints[j].v = vtx->y2d[vertex_idx];\n                    if (min_x == -1 || vtx->x2d[vertex_idx] < min_x) min_x = vtx->x2d[vertex_idx];\n                    if (max_x == -1 || vtx->x2d[vertex_idx] > max_x) max_x = vtx->x2d[vertex_idx];\n                    if (min_y == -1 || vtx->y2d[vertex_idx] < min_y) min_y = vtx->y2d[vertex_idx];\n                    if (max_y == -1 || vtx->y2d[vertex_idx] > max_y) max_y = vtx->y2d[vertex_idx];\n                }\n            }\n            poly->polyBBox.h1 = min_x;\n            poly->polyBBox.v1 = min_y;\n            poly->polyBBox.h2 = max_x;\n            poly->polyBBox.v2 = max_y;\n            SetSolidPenPat(14);\n            GetPenPat(pat);\n            FillPoly(polyHandle, pat);\n            SetSolidPenPat(7);\n            FramePoly(polyHandle);\n            valid_faces_drawn++;\n            if (faces->vertex_count[face_id] == 3) triangle_count++;\n            else if (faces->vertex_count[face_id] == 4) quad_count++;\n        } else {\n            invalid_faces_skipped++;\n        }\n    }\n    \n\n}\n\nvoid DoColor() {\n        Rect r;\n        unsigned char pstr[4];  \n\n        SetRect (&r, 0, 1, mode / 320 *10, 11);\n        for (int i = 0; i < 16; i++) {\n            SetSolidPenPat(i);\n            PaintRect(&r);\n\n            if (i == 0) {\n                SetSolidPenPat(15); \n                FrameRect(&r);\n            }\n\n            MoveTo(r.h1, r.v2+10);\n            \n            if (i < 10) {\n                pstr[0] = 1;           \n                pstr[1] = '0' + i;     \n            } else {\n                pstr[0] = 2;           \n                pstr[1] = '0' + (i / 10);      \n                pstr[2] = '0' + (i % 10);      \n            }\n            DrawString(pstr);\n            OffsetRect(&r, 20, 0);\n        }\n}\n\nvoid DoText() {\n        shroff();\n        putchar((char) 12); \n}\n    int main() {\n        Model3D* model;\n        ObserverParams params;\n        char filename[100];\n        char input[50];\n        int colorpalette = 0; \n\n    newmodel:\n        printf("===================================\n");\n        printf("       3D OBJ file viewer\n");\n        printf("===================================\n\n");\n\n        \n        model = createModel3D();\n        if (model == NULL) {\n            printf("Error: Unable to allocate memory for 3D model\n");\n            printf("Press any key to quit...\n");\n            keypress();\n            return 1;\n        }\n\n        \n        printf("Enter the filename to read: ");\n        if (fgets(filename, sizeof(filename), stdin) != NULL) {\n            size_t len = strlen(filename);\n            if (len > 0 && filename[len-1] == '\n') {\n                filename[len-1] = '\0';\n            }\n        }\n\n        \n        if (loadModel3D(model, filename) < 0) {\n            printf("\nError loading file\n");\n            printf("Press any key to quit...\n");\n            keypress();\n            destroyModel3D(model);\n            return 1;\n        }\n\n        \n        getObserverParams(&params);\n\n    bigloop:\n        \n        printf("Processing model...\n");\n        processModelFast(model, &params, filename);\n\n    loopReDraw:\n        {\n            int key = 0;\n            char input[50];\n\n            if (model->faces.face_count > 0) {\n                \n                startgraph(mode);\n                \n                drawPolygons(model, model->faces.vertex_count, model->faces.face_count, model->vertices.vertex_count);\n                \n                if (colorpalette == 1) { \n                    DoColor(); \n                }\n\n                \n        asm \n            {\n            sep #0x20\n        loop:\n            lda >0xC000     \n            bpl loop        \n            and #0x007f     \n            sta >0xC010     \n            sta key         \n            rep #0x30\n            }\n\n        endgraph();        \n        }\n\n        DoText();           \n\n    #if ENABLE_DEBUG_SAVE\n        sprintf(input, "You pressed key code: %d\n", key);\n        printf("%s", input);\n    #endif\n\n        \n        switch (key) {\n            case 32:  \n                printf("===================================\n");\n                printf(" Model information and parameters\n");\n                printf("===================================\n");\n                printf("Model: %s\n", filename);\n                printf("Vertices: %d, Faces: %d\n", model->vertices.vertex_count, model->faces.face_count);\n                printf("Observer Parameters:\n");\n                printf("    Distance: %.2f\n", FIXED_TO_FLOAT(params.distance));\n                printf("    Horizontal Angle: %d°\n", params.angle_h);\n                printf("    Vertical Angle: %d°\n", params.angle_v);\n                printf("    Screen Rotation Angle: %d°\n", params.angle_w);\n                printf("===================================\n");\n                printf("\n");\n                printf("Press any key to continue...\n");\n                keypress();\n                goto loopReDraw;\n\n            case 65:  \n            case 97:  \n                params.distance = params.distance - (params.distance / 10);\n                goto bigloop;\n\n            case 90:  \n            case 122: \n                params.distance = params.distance + (params.distance / 10);\n                goto bigloop;\n\n            case 21:  \n                params.angle_h = normalize_deg(params.angle_h + 10);\n                goto bigloop;\n\n            case 8:   \n                params.angle_h = normalize_deg(params.angle_h - 10);\n                goto bigloop;\n\n            case 10:  \n                params.angle_v = normalize_deg(params.angle_v - 10);\n                goto bigloop;\n\n            case 11:  \n                params.angle_v = normalize_deg(params.angle_v + 10);\n                goto bigloop;\n\n            case 87:  \n            case 119: \n                params.angle_w = normalize_deg(params.angle_w + 10);\n                goto bigloop;\n\n            case 88:  \n            case 120: \n                params.angle_w = normalize_deg(params.angle_w - 10);\n                goto bigloop;\n        \n            case 67:  \n            case 99:  \n                colorpalette ^= 1; \n                goto loopReDraw;\n\n            case 78:  \n            case 110: \n                destroyModel3D(model);\n                goto newmodel;\n        \n            \n            case 72:  \n            case 104: \n                printf("===================================\n");\n                printf("    HELP - Keyboard Controller\n");\n                printf("===================================\n\n");\n                printf("Space: Display model info\n");\n                printf("A/Z: Increase/Decrease distance\n");\n                printf("Arrow Left/Right: Decrease/Increase horizontal angle\n");\n                printf("Arrow Up/Down: Increase/Decrease vertical angle\n");\n                printf("W/X: Increase/Decrease screen rotation angle\n");\n                printf("C: Toggle color palette display\n");\n                printf("N: Load new model\n");\n                printf("H: Display this help message\n");\n                printf("ESC: Quit program\n");\n                printf("===================================\n");\n                printf("\n");\n                printf("Press any key to continue...\n");\n                keypress();\n                goto loopReDraw;\n\n            case 27:  \n                goto end;\n            \n            default:  \n                goto loopReDraw;\n        }\n        }  \n\n        end:\n        \n        \n        if (globalPolyHandle != NULL) {\n            if (poly_handle_locked) {\n                HUnlock(globalPolyHandle);\n            }\n            DisposeHandle(globalPolyHandle);\n            globalPolyHandle = NULL;\n        }\n        destroyModel3D(model);\n        return 0;\n    }